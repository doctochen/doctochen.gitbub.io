<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />

    

    
    <title>紫阳的BLOG</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="" />
    
    <meta name="description" content="一.快速排序题目传送门：https:&#x2F;&#x2F;www.acwing.com&#x2F;problem&#x2F;content&#x2F;description&#x2F;787&#x2F; 题目大意：给定一个无序数组，将数组在一定时间内排序后，按顺序输出即可。 快速排序思路：1.在区间上先任取一点对取得的点x左右的数据进行处理，将小于该点的元素放在左边，大于该点的元素放在右边 左右数据处理方法建立两个指针j,i分别在最左边和最右边，对于指针j，如果过">
<meta property="og:type" content="article">
<meta property="og:title" content="紫阳的BLOG">
<meta property="og:url" content="http://example.com/2023/05/30/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/index.html">
<meta property="og:site_name" content="紫阳的BLOG">
<meta property="og:description" content="一.快速排序题目传送门：https:&#x2F;&#x2F;www.acwing.com&#x2F;problem&#x2F;content&#x2F;description&#x2F;787&#x2F; 题目大意：给定一个无序数组，将数组在一定时间内排序后，按顺序输出即可。 快速排序思路：1.在区间上先任取一点对取得的点x左右的数据进行处理，将小于该点的元素放在左边，大于该点的元素放在右边 左右数据处理方法建立两个指针j,i分别在最左边和最右边，对于指针j，如果过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/34314328/1669130391230-422c2efc-0f98-42b6-8a2e-83d5d8eefd5d.jpeg">
<meta property="article:published_time" content="2023-05-30T13:42:48.629Z">
<meta property="article:modified_time" content="2023-05-30T13:41:55.727Z">
<meta property="article:author" content="ZiYang Chen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/34314328/1669130391230-422c2efc-0f98-42b6-8a2e-83d5d8eefd5d.jpeg">
    

    
        <link rel="alternate" href="/atom.xml" title="紫阳的BLOG" type="application/atom+xml" />
    

    
        <link rel="icon" href="/%5Bobject%20Object%5D" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/titillium-web/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">


    
<script src="/libs/jquery/3.5.0/jquery.min.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                    
                                
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">关于</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/welcome">欢迎</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    未分类
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-基础算法模板" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <div class="article-meta">
                
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2023/05/30/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" class="article-date">
       <time datetime="2023-05-30T13:42:48.629Z" itemprop="datePublished">2023-05-30</time>
    </a>
  </div>


<div class="article-date">
  <i class="fa fa-calendar-plus-o"></i>
  <a href="/2023/05/30/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" class="article-date">
     <time datetime="2023-05-30T13:41:55.727Z" itemprop="dateModified">2023-05-30</time>
  </a>
</div>


                

                
                

                

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            

            

            

            <h1 id="一-快速排序"><a href="#一-快速排序" class="headerlink" title="一.快速排序"></a>一.快速排序</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/787/">https://www.acwing.com/problem/content/description/787/</a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个无序数组，将数组在一定时间内排序后，按顺序输出即可。</p>
<h2 id="快速排序思路："><a href="#快速排序思路：" class="headerlink" title="快速排序思路："></a>快速排序思路：</h2><h3 id="1-在区间上先任取一点"><a href="#1-在区间上先任取一点" class="headerlink" title="1.在区间上先任取一点"></a>1.在区间上先任取一点</h3><p>对取得的点x左右的数据进行处理，将小于该点的元素放在左边，大于该点的元素放在右边</p>
<h4 id="左右数据处理方法"><a href="#左右数据处理方法" class="headerlink" title="左右数据处理方法"></a>左右数据处理方法</h4><p>建立两个指针j,i分别在最左边和最右边，对于指针j，如果过其指向的元素小于x，则继续向右移动一位，同样，对于指针i，若其指向的元素大于x，则其指针向左移动一位。当两个指针都停下时，若j&lt;i依然满足，则交换两指针分别指向的元素，否则退出循环。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">	<span class="keyword">do</span> i++; <span class="keyword">while</span> (p[i] &lt; x);</span><br><span class="line">	<span class="keyword">do</span>  j--; <span class="keyword">while</span> (p[j] &gt;x);</span><br><span class="line">	<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">		<span class="built_in">swap</span>(p[j], p[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-继续递归分割出的两个区间"><a href="#2-继续递归分割出的两个区间" class="headerlink" title="2.继续递归分割出的两个区间"></a>2.继续递归分割出的两个区间</h3><p>对于由于点x分成的两个区间a和b，a中的所有元素一定小于b中的任意元素。分析可知，继续对这两个区间进行分割，就能实现对整个数组排序。易知两区间的分界点为跳出循环时右指针的位置，代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Qsort</span>(p,l, j);</span><br><span class="line"><span class="built_in">Qsort</span>(p, j + <span class="number">1</span>, r);</span><br></pre></td></tr></table></figure>
<h3 id="3-确定递归停止条件"><a href="#3-确定递归停止条件" class="headerlink" title="3.确定递归停止条件"></a>3.确定递归停止条件</h3><p>为防止无限递归，当区间总大小为1时就可退出递归，代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码展示："><a href="#完整代码展示：" class="headerlink" title="完整代码展示："></a>完整代码展示：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qsort</span><span class="params">(<span class="type">int</span> p[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> x = p[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> i = l<span class="number">-1</span>; <span class="type">int</span> j = r+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">do</span> i++; <span class="keyword">while</span> (p[i] &lt; x);</span><br><span class="line">		<span class="keyword">do</span>  j--; <span class="keyword">while</span> (p[j] &gt;x);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">			<span class="built_in">swap</span>(p[j], p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Qsort</span>(p,l, j);</span><br><span class="line">	<span class="built_in">Qsort</span>(p, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[j]);</span><br><span class="line">	<span class="built_in">Qsort</span>(p,<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		cout &lt;&lt; p[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h1 id="二-归并排序"><a href="#二-归并排序" class="headerlink" title="二.归并排序"></a>二.归并排序</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/789/">https://www.acwing.com/problem/content/789/</a></p>
<h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定长度为n的一个数组，利用归并排序算法，将其进行从小到大排序，并将其输出</p>
<h2 id="归并排序思路："><a href="#归并排序思路：" class="headerlink" title="归并排序思路："></a>归并排序思路：</h2><h3 id="1-归并基本思想："><a href="#1-归并基本思想：" class="headerlink" title="1.归并基本思想："></a>1.归并基本思想：</h3><p>对于两个有序数组，只要依次从左往右将两个数组的较小值输入到新的数组，则得到的新数组就是有序的。于是，当两个数组长度为1时，可认为其是一个有序数组，分析可知，可用两个长度为1的数组归并为一个长度为2的有序数组，类推，可用两个长度为2的有序数组得到更长的数组。</p>
<h3 id="2-获取当前区间的中点"><a href="#2-获取当前区间的中点" class="headerlink" title="2.获取当前区间的中点"></a>2.获取当前区间的中点</h3><p>因为是对一个数组进行排序，所以可将一个数组等分为两个数组进行操作。</p>
<h3 id="3-进行递归，并确定递归终止条件"><a href="#3-进行递归，并确定递归终止条件" class="headerlink" title="3.进行递归，并确定递归终止条件"></a>3.进行递归，并确定递归终止条件</h3><p>由分析易知，应该分割的两个数组为最左边到中点，和中点到最右边，对两个数组分别进行递归。当递归的数组长度为1时，应停止递归，易知当最左点l&gt;&#x3D;r时，递归因该结束。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">MergeSort</span>(p, l, mid);</span><br><span class="line"><span class="built_in">MergeSort</span>(p, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="type">int</span> i = l; <span class="type">int</span> j = mid+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-进行归并操作"><a href="#4-进行归并操作" class="headerlink" title="4.进行归并操作"></a>4.进行归并操作</h3><p>用两个指针分别指向两个数组的最左边，判断两个指针的大小，将数值小的指针向右移动一位，并将该元素尾插入新数组中，循环操作，直到某个数组的指针到达尾部。<br>最后再将指针未到达终点的数组的剩余元素导入新数组中。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = l; <span class="type">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (p[j] &lt;= p[i]) &#123;</span><br><span class="line">		s[k++] = p[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		s[k++] = p[i++];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)s[k++] = p[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r) s[k++] = p[j++];</span><br></pre></td></tr></table></figure>
<h3 id="5-将新数组元素返回原数组中"><a href="#5-将新数组元素返回原数组中" class="headerlink" title="5.将新数组元素返回原数组中"></a>5.将新数组元素返回原数组中</h3><p>因为是对元素组排序，并且排序后的数组还需在上一轮递归中发挥作用，故应将新数组返回到原数组中。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; j++, i++)</span><br><span class="line">	p[i] = s[j];</span><br></pre></td></tr></table></figure>
<h2 id="完整代码如下："><a href="#完整代码如下：" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> p[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">MergeSort</span>(p, l, mid);</span><br><span class="line">	<span class="built_in">MergeSort</span>(p, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="type">int</span> i = l; <span class="type">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p[j] &lt;= p[i]) &#123;</span><br><span class="line">			s[k++] = p[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			s[k++] = p[i++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)s[k++] = p[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r) s[k++] = p[j++];</span><br><span class="line">	<span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; j++, i++)</span><br><span class="line">		p[i] = s[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[j]);</span><br><span class="line">	<span class="built_in">MergeSort</span>(p, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		cout &lt;&lt; p[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三-逆序对的数量（归并）"><a href="#三-逆序对的数量（归并）" class="headerlink" title="三.逆序对的数量（归并）"></a>三.逆序对的数量（归并）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/790/">https://www.acwing.com/problem/content/790/</a></p>
<h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个长度为n的无序数组p，若对于i&lt;j存在p[i]&gt;p[j],则将这称为一组逆序对，求数组p中的所有逆序对的数量。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>本题可采用归并的思想来解决。<br>对于一个只有两个数的数组，可将这一个数组一分为二，观察两边数组中数的大小。而对于两个较长的有序数组，可确定两个指针，分别指向两个数组的首元素，若左数组指针大于右数组指针，则逆序对的数量增加n-l（n表示左数组长度，l表示该指针移动的次数），并将右指针移动，否则移动左指针。直到两个指针都移动到端点，可求出两个数组间的逆序对数量。</p>
<h3 id="步骤1：确定递归排序"><a href="#步骤1：确定递归排序" class="headerlink" title="步骤1：确定递归排序"></a>步骤1：确定递归排序</h3><p>可将数组不断向下递归，使得子数组越来越小，由于只要只需考虑两个元素在左在右，而其具体位置无关紧要，每次递归结束后，都应当将合并后的数组排序。（对于合并后的数组，其内部可能存在的逆序对已经被计算）<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll res = <span class="built_in">Merge_Find</span>(l, mid) + <span class="built_in">Merge_Find</span>(mid + <span class="number">1</span>, r);</span><br></pre></td></tr></table></figure>
<h3 id="步骤2：确定递归终止条件"><a href="#步骤2：确定递归终止条件" class="headerlink" title="步骤2：确定递归终止条件"></a>步骤2：确定递归终止条件</h3><p>易知，当子数组长度为1时，已经不可能再出现逆序对，此时应当终止递归<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="步骤3：开始执行指针确定和移动的操作"><a href="#步骤3：开始执行指针确定和移动的操作" class="headerlink" title="步骤3：开始执行指针确定和移动的操作"></a>步骤3：开始执行指针确定和移动的操作</h3><p>注意，由于还需对数组进行排序，故需使用另一个数组存下排序后的子数组，最终再反还回元素组，思路可参考归并排序算法。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = l; <span class="type">int</span> j = mid + <span class="number">1</span>; <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (p[i] &lt;= p[j])</span><br><span class="line">	&#123;</span><br><span class="line">		d[k++] = p[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		res += mid - i + <span class="number">1</span>;</span><br><span class="line">		d[k++] = p[j++];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) d[k++] = p[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r) d[k++] = p[j++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, i = l; i &lt;= r; j++, i++)</span><br><span class="line">	p[i] = d[j];</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码如下：-1"><a href="#完整代码如下：-1" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="type">int</span> d[N];</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Merge_Find</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	ll res = <span class="built_in">Merge_Find</span>(l, mid) + <span class="built_in">Merge_Find</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="type">int</span> i = l; <span class="type">int</span> j = mid + <span class="number">1</span>; <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p[i] &lt;= p[j])</span><br><span class="line">		&#123;</span><br><span class="line">			d[k++] = p[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			res += mid - i + <span class="number">1</span>;</span><br><span class="line">			d[k++] = p[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) d[k++] = p[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r) d[k++] = p[j++];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, i = l; i &lt;= r; j++, i++)</span><br><span class="line">		p[i] = d[j];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[j]);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">Merge_Find</span>(<span class="number">0</span>, n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="四-数的范围（二分）"><a href="#四-数的范围（二分）" class="headerlink" title="四.数的范围（二分）"></a>四.数的范围（二分）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/791/">https://www.acwing.com/problem/content/description/791/</a></p>
<h3 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定一个长度为n的有序数组p，查找p中的一个数字，找到该数字在p中的起始下标和最终下标，并输出两个下标。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>因为该数组为有序数组，所以可用二分查找搜查p中的数据。</p>
<h4 id="1-找到数组中心"><a href="#1-找到数组中心" class="headerlink" title="1.找到数组中心"></a>1.找到数组中心</h4><p>若要查找查找点左边的数据，为避免边界问题，mid&#x3D;（l+r+1）&#x2F;2，否则mid&#x3D;（l+r）&#x2F;2.<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> mid = (l + r+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-确定跳出循环的条件"><a href="#2-确定跳出循环的条件" class="headerlink" title="2.确定跳出循环的条件"></a>2.确定跳出循环的条件</h4><p>分析易得，当l&gt;&#x3D;r的时候，此时已经找到所找数据，或者该数据并不存在，此时应跳出循环<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br></pre></td></tr></table></figure>
<h4 id="3-根据判断条件判断区间的更新方式"><a href="#3-根据判断条件判断区间的更新方式" class="headerlink" title="3.根据判断条件判断区间的更新方式"></a>3.根据判断条件判断区间的更新方式</h4><p>若要查找分界点右边的数据，若中点落在目标左边，则l&#x3D;mid+1，若在目标右边，则r&#x3D;mid。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (p[mid] &gt;= x) &#123;</span><br><span class="line">		r = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反，若要查找分界点左边的数据，若终点落在目标左边，则l&#x3D;mid，若是落在目标右边，则r&#x3D;mid-1。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q[mid] &lt;= x) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码如下：-2"><a href="#完整代码如下：-2" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, t;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[j]);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="type">int</span> l = <span class="number">0</span>; <span class="type">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (p[mid] &gt;= x) &#123;</span><br><span class="line">				r = mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				l = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p[r] != x) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		 l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mid = (l + r+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (p[mid] &lt;= x) &#123;</span><br><span class="line">				l = mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				r = mid<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五-KMP字符串"><a href="#五-KMP字符串" class="headerlink" title="五.KMP字符串"></a>五.KMP字符串</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/833/">https://www.acwing.com/problem/content/833/</a></p>
<h2 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个长数组和一个短数组，保证短数组为长数组的子数组，找到该短数组出现的初始下标。</p>
<h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>由于数据量过大，本题应该使用KMP算法进行查找</p>
<h3 id="1-定义next数组含义"><a href="#1-定义next数组含义" class="headerlink" title="1.定义next数组含义"></a>1.定义next数组含义</h3><p>由于我们需要利用每次匹配后得到的信息，所以每次两个数组的指针i和j+1匹配失败时，都应该将j指针向后移动<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/34314328/1669130391230-422c2efc-0f98-42b6-8a2e-83d5d8eefd5d.jpeg"><br>由图观察，如果短数组中的两段红色的数组元素完全相同时，可以将j移动到第一段红色区域的右端点位置，此时易知：短数组的前j个元素是一定和长数组中[i-j+1,i]区间的所有元素全部匹配。再继续进行配对。<br>所以，我们可以定义一个数组next，next[i]&#x3D;j的含义是：在短数组p中，区间[0,j]和区间[i-j+1,i]的所有元素都配对。<br>每次p[j+1]与p[i]配对失败时，都可以将j移动到next[j]，然后继续与p[i]进行匹配。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br></pre></td></tr></table></figure>
<h3 id="2-每次匹配成功后的行为"><a href="#2-每次匹配成功后的行为" class="headerlink" title="2.每次匹配成功后的行为"></a>2.每次匹配成功后的行为</h3><p>每次当p[j+1]和s[i]相等的时候，就把j和i分别自增再继续配对，当j到达p数组的终点时，则成功找到该数组，输出目前下标，并且将j的值再次赋值为next[j]，以进行继续寻找下一个子数组的位置。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">	<span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">	<span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">		cout &lt;&lt; i-m &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		j = ne[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-实现next数组"><a href="#3-实现next数组" class="headerlink" title="3.实现next数组"></a>3.实现next数组</h3><p>分析易知，当j&#x3D;1时，next[j]&#x3D;0，所以可使用两个指针i和j，与长短数组匹配的过程类似，如果p[i]!&#x3D;p[j+1],则，j应向左移动到next[j]的位置，若p[i]&#x3D;p[j+1],则代表着从[1,j]数组的所有元素与区间[i-j+1,i]的元素完全相同，即next[i]&#x3D;j，之后再将i指针后移，直到i到达p的终点位置。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, i=<span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>])j = ne[j];</span><br><span class="line">	<span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">	ne[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码如下：-3"><a href="#完整代码如下：-3" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">char</span> p[M];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; m &gt;&gt; p+<span class="number">1</span> &gt;&gt; n &gt;&gt; s+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, i=<span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>])j = ne[j];</span><br><span class="line">		<span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">		ne[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">		<span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">		<span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">			cout &lt;&lt; i-m &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="comment">//	printf(&quot;%d &quot;,i-m);</span></span><br><span class="line">			j = ne[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h1 id="六-区间和（离散化）"><a href="#六-区间和（离散化）" class="headerlink" title="六.区间和（离散化）"></a>六.区间和（离散化）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/804/">https://www.acwing.com/problem/content/804/</a></p>
<h2 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h2><p>在一个超长的数轴中，所有的下标的数都为0，现对该数轴进行操作，每次在下标为x的地方，使该值增加c，最后询问要求的区间内的元素和</p>
<h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>由于本题的数据分散，故考虑使用离散化算法</p>
<h3 id="1-将插入数据和查询区间所需要的坐标进行离散化操作"><a href="#1-将插入数据和查询区间所需要的坐标进行离散化操作" class="headerlink" title="1.将插入数据和查询区间所需要的坐标进行离散化操作"></a>1.将插入数据和查询区间所需要的坐标进行离散化操作</h3><p>由于数据相互之间的跨度较大，所以可以将每个元素的下标映射到一个新的数组中，按照其顺序进行映射。同时并将插入的坐标和值存入数组中，做后期离散化数组使用，将查询使用的下标一同存入一个数组，用于最后的前缀和查询操作。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, c;</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">	adds.<span class="built_in">push_back</span>(&#123; x,c &#125;);</span><br><span class="line">	alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l, r;</span><br><span class="line">	cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">	q.<span class="built_in">push_back</span>(&#123; l,r &#125;);</span><br><span class="line">	alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">	alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-对离散化的坐标进行排序去重"><a href="#2-对离散化的坐标进行排序去重" class="headerlink" title="2.对离散化的坐标进行排序去重"></a>2.对离散化的坐标进行排序去重</h3><p>因为建立离散化数组和查询区间和时需要使用二分查找来确定坐标x离散化后的坐标，应当将alls数组进行排序和去重<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="3-建立离散化后的数组，并统计其前缀和"><a href="#3-建立离散化后的数组，并统计其前缀和" class="headerlink" title="3.建立离散化后的数组，并统计其前缀和"></a>3.建立离散化后的数组，并统计其前缀和</h3><p>读取adds中的元素 ，对其坐标x查找离散化后的坐标，查找方法利用二分，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findNum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>; <span class="type">int</span> r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (alls[mid] &gt;= x)r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在将更新后的x坐标位置放置插入的元素即可<br>最后使用前缀和算法求离散化数组的前缀和，便于求每个区间和<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ret : adds)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="built_in">findNum</span>(ret.first);</span><br><span class="line">	a[x] += ret.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= alls.<span class="built_in">size</span>(); j++) s[j] = s[j - <span class="number">1</span>] + a[j];</span><br></pre></td></tr></table></figure>
<h3 id="4-根据查询下标，输出结果"><a href="#4-根据查询下标，输出结果" class="headerlink" title="4.根据查询下标，输出结果"></a>4.根据查询下标，输出结果</h3><p>对查询区间的终末下标都进行离散化查询，再利用前缀和输出对应区间和即可</p>
<h2 id="完整代码如下：-4"><a href="#完整代码如下：-4" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> PII = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line">vector&lt;PII&gt; adds, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findNum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>; <span class="type">int</span> r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (alls[mid] &gt;= x)r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, c;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">		adds.<span class="built_in">push_back</span>(&#123; x,c &#125;);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l, r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		q.<span class="built_in">push_back</span>(&#123; l,r &#125;);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">	alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> ret : adds)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">findNum</span>(ret.first);</span><br><span class="line">		a[x] += ret.second;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= alls.<span class="built_in">size</span>(); j++) s[j] = s[j - <span class="number">1</span>] + a[j];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> ret : q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">findNum</span>(ret.first);</span><br><span class="line">		<span class="type">int</span> r = <span class="built_in">findNum</span>(ret.second);</span><br><span class="line">		cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七-Trie树"><a href="#七-Trie树" class="headerlink" title="七.Trie树"></a>七.Trie树</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/837/">https://www.acwing.com/problem/content/837/</a></p>
<h2 id="题目大意：-6"><a href="#题目大意：-6" class="headerlink" title="题目大意："></a>题目大意：</h2><p>维护一堆字符串，可执行两种操作，i表示插入一个字符串，q表示询问某种字符串出现的次数。</p>
<h2 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h2><p>trie树，通过树状结构，从根节点开始，每个字母表示字符串的一个字符，如下trie树表示该树已经存储了6个字符串，分别为ab,acs,ad,bs,bsay,bsa，在每个字符串的结尾处应当做上标记，以用于查询时计算某字符串个数<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/34314328/1669598995419-5f92c912-7fdf-4645-8df4-4ed2c14feb39.jpeg"></p>
<h3 id="Trie树的实现："><a href="#Trie树的实现：" class="headerlink" title="Trie树的实现："></a>Trie树的实现：</h3><p>建立son[N][26]数组,其中，son的第一维表示目前查看节点的下标，第二维表示其儿子的类型，数组的值表示其儿子的下标。<br>再建立cnt[N]数组，cnt[x]用于记录下标为x的点是否为一个字符串的结尾。</p>
<h4 id="实现插入操作："><a href="#实现插入操作：" class="headerlink" title="实现插入操作："></a>实现插入操作：</h4><p>从需插入的·字符串的首元素开始查找，若当前节点的儿子中存在该元素，就从该元素的子节点继续查找插入字符串的下一个字符，如若不存在，则创建该儿子。当插入结束后，通过cnt数组对字符串的出现次数进行统计。<br>代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void insert(char str[])</span><br><span class="line">&#123;</span><br><span class="line">	int p = 0;</span><br><span class="line">	for (int j = 0; str[j]; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		int u = str[j] - &#x27;a&#x27;;</span><br><span class="line">		if (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">		p = son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现查询操作："><a href="#实现查询操作：" class="headerlink" title="实现查询操作："></a>实现查询操作：</h4><p>对需查询的字符串的首元素开始查找，若当前节点的儿子中存在该元素，则以该儿子为节点继续查找下一个字符，直到查询到该字符串的最后一个字符，然后返回cnt[n]的值，即表示该字符串出现的次数。如果中途出现某节点的儿子中不存在当前寻找字符，则直接返回0.<br>代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int quiry(char str[])</span><br><span class="line">&#123;</span><br><span class="line">	int p=0;</span><br><span class="line">	for (int j = 0; str[j]; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		int u = str[j] - &#x27;a&#x27;;</span><br><span class="line">		if (!son[p][u])return 0;</span><br><span class="line">		p = son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	return cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="完整代码如下：-5"><a href="#完整代码如下：-5" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100010;</span><br><span class="line">int son[N][26], cnt[N], idx;</span><br><span class="line">char str[N];</span><br><span class="line"></span><br><span class="line">void insert(char str[])</span><br><span class="line">&#123;</span><br><span class="line">	int p = 0;</span><br><span class="line">	for (int j = 0; str[j]; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		int u = str[j] - &#x27;a&#x27;;</span><br><span class="line">		if (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">		p = son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int quiry(char str[])</span><br><span class="line">&#123;</span><br><span class="line">	int p=0;</span><br><span class="line">	for (int j = 0; str[j]; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		int u = str[j] - &#x27;a&#x27;;</span><br><span class="line">		if (!son[p][u])return 0;</span><br><span class="line">		p = son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	return cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t; cin &gt;&gt; t;</span><br><span class="line">	while (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		char s[2]; </span><br><span class="line">		scanf(&quot;%s %s&quot;,s,str);</span><br><span class="line">		if (s[0] == &#x27;I&#x27;)insert(str);</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; quiry(str) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八-区间合并（并查集）"><a href="#八-区间合并（并查集）" class="headerlink" title="八.区间合并（并查集）"></a>八.区间合并（并查集）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/838/">https://www.acwing.com/problem/content/838/</a></p>
<h2 id="题目大意：-7"><a href="#题目大意：-7" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定n个数，起始时每个数各占据一个集合，对这些集合的数可以执行两种操作。<br>1.将两个数所在的区间合并<br>2.查看两个数是否在同一区间</p>
<h2 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h2><p>此题可用并查集的思路解决</p>
<h3 id="1-将元素以树的形式存储"><a href="#1-将元素以树的形式存储" class="headerlink" title="1.将元素以树的形式存储"></a>1.将元素以树的形式存储</h3><p>每个集合的元素有着同一个根节点，图示如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/34314328/1669889193283-10cc5611-acad-42fd-b471-3fdad95e383d.jpeg"><br>在上图中，1，2，3，4和5，6，7，8，9就分别在两个集合中。</p>
<h3 id="2-查找每个元素属于某一区间"><a href="#2-查找每个元素属于某一区间" class="headerlink" title="2.查找每个元素属于某一区间"></a>2.查找每个元素属于某一区间</h3><p>简单分析，只要遍历到该元素的根节点，就可知道该元素属于哪一个区间。可以使用一个数组p来存放每个数组的父辈节点，只有当p[x]&#x3D;x时，才能到达根节点。此过程可递归简化处理，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findNum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">findNum</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-进行区间之间的合并"><a href="#3-进行区间之间的合并" class="headerlink" title="3.进行区间之间的合并"></a>3.进行区间之间的合并</h3><p>对于原先的两个区间，只要是其中的一个根节点的父辈变成另一个根节点即可，图示如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/34314328/1669889194205-ee0060f9-31f4-47a6-8874-45b1e9796c35.jpeg"><br>如图，我们将根节点1连接在根节点2的下面，此时1不在为根节点，左边的所有元素所在的区间也都属于了根节点2，实现的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[findNum(a)] = findNum(b);</span><br></pre></td></tr></table></figure>
<h2 id="完整代码如下：-6"><a href="#完整代码如下：-6" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findNum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">findNum</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) p[j] = j;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span> (*op == <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">findNum</span>(a)] = <span class="built_in">findNum</span>(b);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">findNum</span>(a) == <span class="built_in">findNum</span>(b))</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="九-堆排序"><a href="#九-堆排序" class="headerlink" title="九.堆排序"></a>九.堆排序</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/840/">https://www.acwing.com/problem/content/840/</a></p>
<h2 id="题目大意：-8"><a href="#题目大意：-8" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定长度为n的无序数组p，利用堆排序的排序算法排序后，由小到大输出排序后数组的前m个元素</p>
<h2 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h2><h3 id="1-堆是一种完全二叉树的数据结构"><a href="#1-堆是一种完全二叉树的数据结构" class="headerlink" title="1.堆是一种完全二叉树的数据结构"></a>1.堆是一种完全二叉树的数据结构</h3><p>本题可使用小根堆的模式解决，图示如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/34314328/1670050663177-98e495fb-fd25-4422-8b1a-ce11d2c9d496.jpeg"><br>对于一个小根堆，我们应该使其的每一个节点小于他的两个儿子节点，所以，易知，根节点的元素必定为所有元素中最小的值。</p>
<h3 id="2-构建堆结构"><a href="#2-构建堆结构" class="headerlink" title="2.构建堆结构"></a>2.构建堆结构</h3><p>对于堆结构进行观察，不难发现，对任意一个节点i，如果其存在儿子节点，则其儿子的小标必为2<em>i和2</em>i+1。</p>
<h4 id="实现down操作"><a href="#实现down操作" class="headerlink" title="实现down操作"></a>实现down操作</h4><p>对于数组中的任意一个元素，如果发现其大于他的一个儿子节点，则应该将其和其·儿子进行交换，并且递归判断交换后儿子节点的数值是否大于该点的儿子节点，代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void down(int x)</span><br><span class="line">&#123;</span><br><span class="line">	int t = x;</span><br><span class="line">	if (x * 2 &lt;= cnt &amp;&amp; p[x * 2] &lt; p[t])t = 2*x;</span><br><span class="line">	if (x * 2 + 1 &lt;= cnt &amp;&amp; p[x * 2 + 1] &lt; p[t])t = x * 2 + 1;</span><br><span class="line">	if (x != t)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(p[x], p[t]);</span><br><span class="line">		down(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>分析易知，对于从n/2到n的元素一定处于二叉树的最底层，不存在儿子节点，所以只要从n/2到1遍历每一个元素，对其执行一次down操作，即可实现堆结构。
</code></pre>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int j = n / 2; j; j--)down(j);</span><br></pre></td></tr></table></figure>
<h3 id="3-取出根节点元素"><a href="#3-取出根节点元素" class="headerlink" title="3.取出根节点元素"></a>3.取出根节点元素</h3><p>由于每次从低到高输出元素，我们只需没去输出p[1]的值，再将目前的叶子节点覆盖掉根节点，再对1号元素执行一次down操作即可，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int j = 1; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; p[1] &lt;&lt; &quot; &quot;;</span><br><span class="line">	p[1] = p[ cnt--];</span><br><span class="line">	down(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码如下：-7"><a href="#完整代码如下：-7" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100010;</span><br><span class="line">int p[N];</span><br><span class="line">int cnt;</span><br><span class="line"></span><br><span class="line">void down(int x)</span><br><span class="line">&#123;</span><br><span class="line">	int t = x;</span><br><span class="line">	if (x * 2 &lt;= cnt &amp;&amp; p[x * 2] &lt; p[t])t = 2*x;</span><br><span class="line">	if (x * 2 + 1 &lt;= cnt &amp;&amp; p[x * 2 + 1] &lt; p[t])t = x * 2 + 1;</span><br><span class="line">	if (x != t)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(p[x], p[t]);</span><br><span class="line">		down(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for (int j = 1; j &lt;= n; j++)scanf(&quot;%d&quot;, &amp;p[j]);</span><br><span class="line">	cnt = n;</span><br><span class="line">	for (int j = n / 2; j; j--)down(j);</span><br><span class="line">	for (int j = 1; j &lt;= m; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; p[1] &lt;&lt; &quot; &quot;;</span><br><span class="line">		p[1] = p[ cnt--];</span><br><span class="line">		down(1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十-模拟散列表"><a href="#十-模拟散列表" class="headerlink" title="十.模拟散列表"></a>十.模拟散列表</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/842/">https://www.acwing.com/problem/content/842/</a></p>
<h2 id="大意："><a href="#大意：" class="headerlink" title="大意："></a>大意：</h2><p>维护一个散列表的数据结构，可以进行以下的操作：<br>1.向结构中插入一个数<br>2.查询这个数是否存在</p>
<h2 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h2><h3 id="1-哈希处理"><a href="#1-哈希处理" class="headerlink" title="1.哈希处理"></a>1.哈希处理</h3><p>可以将插入的数进行哈希处理，即将数据进行取模处理，在把取模后的数据存储在对应下标的位置。当两个数据取模后数据相同时，会发生哈希冲突。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x=(u%N+N)%N;</span><br></pre></td></tr></table></figure>
<h3 id="2-解决哈希冲突"><a href="#2-解决哈希冲突" class="headerlink" title="2.解决哈希冲突"></a>2.解决哈希冲突</h3><p>实现一个find函数，以寻找x的值应当存在的位置。实现原理如下：<br>先将数组p的所有值赋为不可能取到的值null，对需要查询位置的值x，对其进行哈希处理后得到u，先查看p[u]的值，如果其值为u或者null，则该位置就为其该存在的位置。否则，就查看数组p的下一个位置，直到找到数据为null或者为u的数据为止。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int findNum(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int x=(u%N+N)%N;</span><br><span class="line">	while (p[x] != null &amp;&amp; p[x] != u)</span><br><span class="line">	&#123;</span><br><span class="line">		x++;</span><br><span class="line">		if (x == N)x = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-解决两种操作"><a href="#3-解决两种操作" class="headerlink" title="3.解决两种操作"></a>3.解决两种操作</h3><p>对于插入操作，通过find函数，找到对应位置，修改数组p的值即可，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (s[0] == &#x27;I&#x27;) p[findNum(x)] = x;</span><br></pre></td></tr></table></figure>
<pre><code>对于查询操作，利用find找对对应位置，若为null则不存在，否则就已经存在。代码如下:
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (p[findNum(x)] == null)cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">else</span><br><span class="line">	cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="3-完整代码如下："><a href="#3-完整代码如下：" class="headerlink" title="3.完整代码如下："></a>3.完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findNum</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=(u%N+N)%N;</span><br><span class="line">    <span class="keyword">while</span> (p[x] != null &amp;&amp; p[x] != u)</span><br><span class="line">        &#123;</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">if</span> (x == N)x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            string s; cin &gt;&gt; s&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) p[<span class="built_in">findNum</span>(x)] = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[<span class="built_in">findNum</span>(x)] == null)cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十一-N皇后问题（dfs）"><a href="#十一-N皇后问题（dfs）" class="headerlink" title="十一.N皇后问题（dfs）"></a>十一.N皇后问题（dfs）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/845/">https://www.acwing.com/problem/content/845/</a></p>
<h2 id="大意：-1"><a href="#大意：-1" class="headerlink" title="大意："></a>大意：</h2><p>给定一个NXN的棋盘，在其中放置N个皇后，使得所有的皇后之间不能彼此攻击到，输出所有满足条件的皇后布局。</p>
<h2 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h2><h3 id="1-确定搜索方式"><a href="#1-确定搜索方式" class="headerlink" title="1.确定搜索方式"></a>1.确定搜索方式</h3><p>由于皇后特殊的攻击方式，要求所有的皇后不会彼此攻击，对于每一行都只可能存在一个皇后。由此，我们可以一行一行的搜索。<br>根据皇后的攻击方式，需要定义三个bool类型数组，用于判断遍历到的节点是否可以放置皇后。</p>
<h3 id="2-进行递归搜索"><a href="#2-进行递归搜索" class="headerlink" title="2.进行递归搜索"></a>2.进行递归搜索</h3><p>遍历当前搜索深度的每一个节点（搜索的当前行），判断当前节点是否可以放置皇后，如果可以，则继续搜索下一层，并将这一层的该节点数组修改为‘Q’.直到搜索到最后一层时，打印搜索出的皇后布局，终止递归。</p>
<h3 id="3-恢复现场"><a href="#3-恢复现场" class="headerlink" title="3.恢复现场"></a>3.恢复现场</h3><p>对于当前行而言，当下一行的递归结束时，自身需要遍历下一个节点，此时应该修改节点数组和bool数组，防止打印时出现错误。</p>
<h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> p[N][N];</span><br><span class="line"><span class="type">bool</span> col[N], le[N], lr[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="built_in">puts</span>(p[j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[j] &amp;&amp; !le[j + x] &amp;&amp; !lr[n - x + j])</span><br><span class="line">            &#123;</span><br><span class="line">                p[x][j] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                col[j] = le[j + x] = lr[n - x + j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">                col[j] = le[j + x] = lr[n - x + j] = <span class="literal">false</span>;</span><br><span class="line">                p[x][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)p[j][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十二-走迷宫（bfs）"><a href="#十二-走迷宫（bfs）" class="headerlink" title="十二.走迷宫（bfs）"></a>十二.走迷宫（bfs）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/846/">https://www.acwing.com/problem/content/846/</a></p>
<h2 id="大意：-2"><a href="#大意：-2" class="headerlink" title="大意："></a>大意：</h2><p>给定一个用二维数组代替的迷宫，0代表路，1代表墙。问，从左上角移动到右下角，至少要移动多少次。题目保证至少会有一条通路，可以到达右下角。</p>
<h2 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h2><p>对于该问题，很明显可以使用深度优先搜索来解决。</p>
<h3 id="1-确定搜索方式-1"><a href="#1-确定搜索方式-1" class="headerlink" title="1.确定搜索方式"></a>1.确定搜索方式</h3><p>将数组中每一个元素都是为图上的一点，其相邻的元素，就为图中有边的两个点。所以，只要从第一个点开始搜索，遍历所有相邻的点，看是否可以前往。易知，若一个在本层次前就已经被搜索过，必然不可能为到达终点的最小路径。</p>
<h3 id="2-搜索的具体实现"><a href="#2-搜索的具体实现" class="headerlink" title="2.搜索的具体实现"></a>2.搜索的具体实现</h3><p>首先，定义数组d，确定到达每一个点时所用的最小步数。由于要深度搜索每一层的元素，所以使用队列q。<br>首先将（0，0）位置元素插入队头，判断四周元素是否有可以前去的路，如果有，就将其插入队头，并将d的值赋为当前队顶d值加一，再弹出队顶元素，表示当前节点的所有临节点已经遍历结束。如果无可前去的路，就直接弹出队顶。一直执行上述操作，直到队列为空，此时已经遍历完了所有情况，最终输出d[n-1][m-1]的值即可。</p>
<h2 id="完整代码如下：-8"><a href="#完整代码如下：-8" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> PII = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> p[N][N],d[N][N];</span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; <span class="number">0</span>,<span class="number">0</span> &#125;);</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, dy[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> x = t.first+dx[j], y = t.second+dy[j];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; n &amp;&amp; y &lt; m &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; p[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123; x,y &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            cin &gt;&gt; p[j][i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十三-树的重心（邻接表）"><a href="#十三-树的重心（邻接表）" class="headerlink" title="十三.树的重心（邻接表）"></a>十三.树的重心（邻接表）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/848/">https://www.acwing.com/problem/content/848/</a></p>
<h2 id="大意：-3"><a href="#大意：-3" class="headerlink" title="大意："></a>大意：</h2><p>给定一个树，求删去该树中的重心后，剩下的连通块中点数的最大值。重心定义如下：重心指的是树上的一个节点，删除该节点后，剩下的连通块中点数的最大值最小。</p>
<h2 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h2><h3 id="1-邻接表的实现"><a href="#1-邻接表的实现" class="headerlink" title="1.邻接表的实现"></a>1.邻接表的实现</h3><p>对于树的存储，一般使用邻接表进行存储。邻接表从本质来说，是由多个链表实现。每一个链表的头节点代表着树的其中一个节点，而链表中的每一个元素表示与该节点之间有边的节点。向邻接表进行头插节点的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>对该串代码分析，idx代表着每一个节点的标号，e数组表示链表中的值，ne指的是该标号后的下一个值，h数组代表头节点。每次插入新的值的时候，都会有一个独立的idx值，先将e[idx]修改为b，注意此时的h[a]的含义为原先该链表的第一个节点，最后在将h[a]赋值为当前节点。
</code></pre>
<h3 id="2-确定重心"><a href="#2-确定重心" class="headerlink" title="2.确定重心"></a>2.确定重心</h3><p>欲知道树的重心在哪，可以遍历树的每一个节点，并找出删除该节点后剩下连通块的点数的最大值。对于快速遍历并计算，可以使用深度优先搜索的思路递归遍历。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/34314328/1671889495636-44c31b95-4f68-45fe-a765-67c1cfab96a9.jpeg"><br>    对该图进行分析，如若试图求2号删除后剩下连通块的点数最大值，可以由4号子树的总结点数，5号的总节点数，整个树的总结点数减去2号子树总节点的数目相比较而得。同时，每一个节点的子树总结点数目都可以递归从子节点中求得。</p>
<h4 id="dsf函数的具体实现"><a href="#dsf函数的具体实现" class="headerlink" title="dsf函数的具体实现"></a>dsf函数的具体实现</h4><p>首先定义一个st数组，用于记录该点是否已经被搜索过。<br>确定dfs函数返回该节点字数的总节点数。<br>搜索当前值对应的链表，对于其中的元素，如果没有被搜索过，就递归到该元素，并接受返回值。同过返回值求出所需的值。最后每次在返回值之前，判断是否为重心即可。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	st[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="type">int</span> size = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = h[u]; j != <span class="number">-1</span>; j = ne[j])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = e[j];</span><br><span class="line">		<span class="keyword">if</span> (!st[x])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> s = <span class="built_in">dfs</span>(x);</span><br><span class="line">			size = <span class="built_in">max</span>(size, s);</span><br><span class="line">			sum += s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	size = <span class="built_in">max</span>(size, n - sum<span class="number">-1</span>);</span><br><span class="line">	ans = <span class="built_in">min</span>(ans, size);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> sum+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="完整代码如下：-9"><a href="#完整代码如下：-9" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = N * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> idx, ne[M], e[M], h[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> ans = M,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	st[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="type">int</span> size = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = h[u]; j != <span class="number">-1</span>; j = ne[j])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = e[j];</span><br><span class="line">		<span class="keyword">if</span> (!st[x])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> s = <span class="built_in">dfs</span>(x);</span><br><span class="line">			size = <span class="built_in">max</span>(size, s);</span><br><span class="line">			sum += s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	size = <span class="built_in">max</span>(size, n - sum<span class="number">-1</span>);</span><br><span class="line">	ans = <span class="built_in">min</span>(ans, size);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> sum+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">		<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="built_in">add</span>(a, b);<span class="built_in">add</span>(b,a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十四-滑动窗口（单调队列）"><a href="#十四-滑动窗口（单调队列）" class="headerlink" title="十四.滑动窗口（单调队列）"></a>十四.滑动窗口（单调队列）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/156/">https://www.acwing.com/problem/content/156/</a></p>
<h2 id="大意：-4"><a href="#大意：-4" class="headerlink" title="大意："></a>大意：</h2><p>给定一个长度为n的数组p，一个长度为k的滑动窗口从左往右在p上滑动。依次输出滑动窗口中的最大值和最小值。</p>
<h2 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h2><p>首先考虑暴力解法，每次遍历窗口内的所有值，输出最大值，然后再将窗口向右移动，再重复遍历操作。</p>
<h3 id="利用单调队列优化"><a href="#利用单调队列优化" class="headerlink" title="利用单调队列优化"></a>利用单调队列优化</h3><p>对于滑动窗口，我们可以使用一个特殊的队列来存储。每次窗口移动时，只需要分别入队和出队一次即可做到。考虑移动时的一个问题，如果入队前的队末元素小于即将入队的元素，那么该队末元素将不可能被输出，那么我们可以考虑直接将其出队（所以该队列需要能从队尾出队），然后继续判断更新后的队末元素是否依旧小于即将入队元素，重复上述的操作即可。<br>不难发现，经过上述操作之后，队列中的元素一定是从大到小排列的，即形成了一个单调队列。每次欲输出当前窗口的最大值，只需输出队头的元素即可。</p>
<h2 id="完整代码如下：-10"><a href="#完整代码如下：-10" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[j]);</span><br><span class="line">	<span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (hh &lt;= tt &amp;&amp; j - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">		<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[j])tt--;</span><br><span class="line">		q[++tt] = j;</span><br><span class="line">		<span class="keyword">if</span> (j &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	hh=<span class="number">0</span>;tt=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (hh &lt;= tt &amp;&amp; j - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">		<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[j])tt--;</span><br><span class="line">		q[++tt] = j;</span><br><span class="line">		<span class="keyword">if</span> (j &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十五-Dijkstra实现最短路"><a href="#十五-Dijkstra实现最短路" class="headerlink" title="十五.Dijkstra实现最短路"></a>十五.Dijkstra实现最短路</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/851/">https://www.acwing.com/problem/content/851/</a></p>
<h2 id="大意：-5"><a href="#大意：-5" class="headerlink" title="大意："></a>大意：</h2><p>给定n个点m个边组成的图，求出1号点到第n号点的最短路径。</p>
<h2 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h2><h3 id="1-用邻接矩阵存入图"><a href="#1-用邻接矩阵存入图" class="headerlink" title="1.用邻接矩阵存入图"></a>1.用邻接矩阵存入图</h3><p>由于本题为稠密图，考虑使用邻接矩阵对图进行存储，邻接矩阵g[a][b]&#x3D;c代表，a到b存在一个边，边的权重为c。由于本题存在重边的情况，由于最短路问题可知，重边中较长的边一定不会被选择，所以将邻接矩阵初始化为无穷大，每次存边时，都取更小值即可。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a, b, x; cin &gt;&gt; a &gt;&gt; b &gt;&gt; x;</span><br><span class="line">	g[a][b] = <span class="built_in">min</span>(g[a][b], x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-初始化每个点到1号点的距离"><a href="#2-初始化每个点到1号点的距离" class="headerlink" title="2.初始化每个点到1号点的距离"></a>2.初始化每个点到1号点的距离</h3><p>将1号点到自己的距离初始化为1，其他所有点到1号点的距离都先初始化为无穷大，以便下一步的处理。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-更新其余点到1号点的距离"><a href="#3-更新其余点到1号点的距离" class="headerlink" title="3.更新其余点到1号点的距离"></a>3.更新其余点到1号点的距离</h3><p>遍历所有的点，找到未被用于更新过的且距离1号点最近的一个点，期间使用st[]数组记录某个节点是否被选择过。接下来，用该点去更新其他所有点到1号点的距离，如果该点到1号点的距离加上权重大于更新点原先到1号点的距离，就更新其距离。最后输出dist[n]的值，即为答案。<br>如果dist[n]值为无穷大，即代表n无法到达1号点，特判这种情况即可。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		<span class="keyword">if</span> (!st[j] &amp;&amp; (k == <span class="number">-1</span> || dist[k] &gt; dist[j]))</span><br><span class="line">			k = j;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		dist[j] = <span class="built_in">min</span>(dist[j], dist[k] + g[k][j]);</span><br><span class="line">		st[k]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br></pre></td></tr></table></figure>
<h2 id="完整代码如下：-11"><a href="#完整代码如下：-11" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> st[N],n ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (!st[j] &amp;&amp; (k == <span class="number">-1</span> || dist[k] &gt; dist[j]))</span><br><span class="line">				k = j;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			dist[j] = <span class="built_in">min</span>(dist[j], dist[k] + g[k][j]);</span><br><span class="line">			st[k]=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, x; cin &gt;&gt; a &gt;&gt; b &gt;&gt; x;</span><br><span class="line">		g[a][b] = <span class="built_in">min</span>(g[a][b], x);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十六-有边数限制的最短路（bellman-ford）"><a href="#十六-有边数限制的最短路（bellman-ford）" class="headerlink" title="十六.有边数限制的最短路（bellman_ford）"></a>十六.有边数限制的最短路（bellman_ford）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/855/">https://www.acwing.com/problem/content/855/</a></p>
<h2 id="大意：-6"><a href="#大意：-6" class="headerlink" title="大意："></a>大意：</h2><p>给定一个n个点，m条边的有向图，求出从1号点到n号点的最多经过k条边情况的最短路径。</p>
<h2 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h2><h3 id="利用结构体存储图"><a href="#利用结构体存储图" class="headerlink" title="利用结构体存储图"></a>利用结构体存储图</h3><p>对于bellman_ford算法，对于图的存储只需要利用一个结构体数组即可，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">note</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;g[N];</span><br></pre></td></tr></table></figure>
<h3 id="初始化所有点的距离"><a href="#初始化所有点的距离" class="headerlink" title="初始化所有点的距离"></a>初始化所有点的距离</h3><p>对于除了1号点外所有的点，都初始化为无穷大，而1号点初始化为0即可。</p>
<h3 id="更新所有点到1号点的距离"><a href="#更新所有点到1号点的距离" class="headerlink" title="更新所有点到1号点的距离"></a>更新所有点到1号点的距离</h3><p>遍历图中所有的边，对于一条边a-&gt;b而言，都用a到1号点的距离加上此边的权重和b到1号点距离的更小值来更新b到1号点的距离。可以发现，每次遍历完所有边之后，被有效更新的点都相当于最多比上次遍历多走了一条边，欲最多走k条边，则循环遍历k次即可。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(last, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> x = g[j];</span><br><span class="line">		dist[x.b] = <span class="built_in">min</span>(dist[x.b], last[x.a] + x.c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断n号点到1号点的距离是否有效"><a href="#判断n号点到1号点的距离是否有效" class="headerlink" title="判断n号点到1号点的距离是否有效"></a>判断n号点到1号点的距离是否有效</h3><p>由于图中可能存在负权边，无穷大也可能会被无效的更新，所以，只要只要n点到1号点的距离大于无穷大的一半即可。</p>
<h2 id="完整代码如下：-12"><a href="#完整代码如下：-12" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">note</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;g[N];</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N], last[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(last, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> x = g[j];</span><br><span class="line">			dist[x.b] = <span class="built_in">min</span>(dist[x.b], last[x.a] + x.c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;g[j].a, &amp;g[j].b, &amp;g[j].c);</span><br><span class="line">	<span class="built_in">bellman_ford</span>();</span><br><span class="line">	<span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)<span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; dist[n] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十七-spfa求最短路"><a href="#十七-spfa求最短路" class="headerlink" title="十七.spfa求最短路"></a>十七.spfa求最短路</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/853/">https://www.acwing.com/problem/content/853/</a></p>
<h2 id="大意：-7"><a href="#大意：-7" class="headerlink" title="大意："></a>大意：</h2><p>给定一个n个点，m条边的有向图，其中边权可以为负数，问1号点到n号点的最短路径，如果不能到达n号点，则输出impossible。</p>
<h2 id="思路：-14"><a href="#思路：-14" class="headerlink" title="思路："></a>思路：</h2><h3 id="确定用于更新的点："><a href="#确定用于更新的点：" class="headerlink" title="确定用于更新的点："></a>确定用于更新的点：</h3><p>由于最短路的性质可知，每次只有刚刚被更新过的点才能用于更新其他的点，所以我们可以使用一个队列按照顺序存储被更新的点，每个点被用于更新了之后再弹出队列。其中1号点初状态就加入队列，并把距离初始化为0，其余所有点都初始化为无穷大。</p>
<h3 id="更新方式："><a href="#更新方式：" class="headerlink" title="更新方式："></a>更新方式：</h3><p>每次从队列中抽出一个点，遍历这个点上的所有的边，只要该点距离加上边的权重小于被更新点·的距离，就将其距离更新，并将这个被更新的点给加入到队列中。</p>
<h2 id="完整代码如下：-13"><a href="#完整代码如下：-13" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], w[N], idx,h[N];</span><br><span class="line"><span class="type">int</span> dist[N], st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>); st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		st[x] = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = h[x]; j != <span class="number">-1</span>; j = ne[j])</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="type">int</span> k=e[j];</span><br><span class="line">			<span class="keyword">if</span> (dist[k] &gt; dist[x] + w[j])</span><br><span class="line">			&#123;</span><br><span class="line">				dist[k] = dist[x] + w[j];</span><br><span class="line">				<span class="keyword">if</span> (!st[k])</span><br><span class="line">				&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(k);</span><br><span class="line">					st[k] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		<span class="built_in">add</span>(a, b, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t = <span class="built_in">spfa</span>();</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>)<span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="十八-spfa判断负环"><a href="#十八-spfa判断负环" class="headerlink" title="十八.spfa判断负环"></a>十八.spfa判断负环</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/854/">https://www.acwing.com/problem/content/854/</a></p>
<h2 id="大意：-8"><a href="#大意：-8" class="headerlink" title="大意："></a>大意：</h2><p>给定一个n个点，m个边个有向图，判断图中是否含有负权回路。</p>
<h2 id="思路：-15"><a href="#思路：-15" class="headerlink" title="思路："></a>思路：</h2><p>分别通过图中的所有的点为起点来求到其他所有点的最短路径，易知，如果图中存在负权回路，那么最终到某个点的距离就会大于点的数量n。</p>
<h3 id="初始化队列："><a href="#初始化队列：" class="headerlink" title="初始化队列："></a>初始化队列：</h3><p>由于我们需要对所有的点都作为起点去更新到其他点的距离，所以首先将所有的点都加入到队列中，并全部标记为被使用过。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line">	st[j] = <span class="literal">true</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新每次边距离："><a href="#更新每次边距离：" class="headerlink" title="更新每次边距离："></a>更新每次边距离：</h3><p>每次从队列中弹出一个元素，并将该点再次标记为未使用过。遍历从该点出发的所有的边，如果其当前距离大于该点距离到加上边的权重，则更新其到最近起点的距离，并将边长度加一。只要发现某个点的最短路长度大于点数，则表明存在负权回路。<br>然后将该点加入到队列之中，并标记为被使用过。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">	q.<span class="built_in">pop</span>();</span><br><span class="line">	st[t] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = h[t]; j != <span class="number">-1</span>; j = ne[j])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = e[j];</span><br><span class="line">		<span class="keyword">if</span> (dist[x] &gt; dist[t] + w[j])</span><br><span class="line">		&#123;</span><br><span class="line">			dist[x] = dist[t] + w[j];</span><br><span class="line">			cnt[x] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (cnt[x] &gt;= n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (!st[x])</span><br><span class="line">			&#123;</span><br><span class="line">				q.<span class="built_in">push</span>(x);</span><br><span class="line">				st[x] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码：-1"><a href="#完整代码：-1" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], w[N], h[N], idx,dist[N],cnt[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		st[j] = <span class="literal">true</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		st[t] = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = h[t]; j != <span class="number">-1</span>; j = ne[j])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x = e[j];</span><br><span class="line">			<span class="keyword">if</span> (dist[x] &gt; dist[t] + w[j])</span><br><span class="line">			&#123;</span><br><span class="line">				dist[x] = dist[t] + w[j];</span><br><span class="line">				cnt[x] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (cnt[x] &gt;= n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (!st[x])</span><br><span class="line">				&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(x);</span><br><span class="line">					st[x] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		<span class="built_in">add</span>(a, b, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">spfa</span>())<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十九-Kruskal算法求最小生成树"><a href="#十九-Kruskal算法求最小生成树" class="headerlink" title="十九. Kruskal算法求最小生成树"></a>十九. Kruskal算法求最小生成树</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/861/">https://www.acwing.com/problem/content/861/</a></p>
<h2 id="大意：-9"><a href="#大意：-9" class="headerlink" title="大意："></a>大意：</h2><p>给定一个n个点m个边的无向图，找出其中的最小生成树，输出树中所有点的权重之和。</p>
<h2 id="思路：-16"><a href="#思路：-16" class="headerlink" title="思路："></a>思路：</h2><p>Kruskal算法流程：<br>1.将所有的边通过结构体的方式存入所有的边，在以边的权重为依据，从小到大对所有的边进行排序操作。<br>2.通过并查集的数据结构，依次遍历所有的边，判断边的两头a，b是否属于同一个集合，如果不属于同一集合，就将他俩置于同一集合中。并将生成树总权重加上该边的边权，并将cnt加一，其中cnt表示生成树中点的数量。<br>3.如果点数小于n，则表示该图并不连通，输出impossible，否则，输出总权重即可。</p>
<h2 id="完整代码：-2"><a href="#完整代码：-2" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>, INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a, b, w;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;n)<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; n.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(Edge, Edge + m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)p[j] = j;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a = Edge[j].a, b = Edge[j].b, w = Edge[j].w;</span><br><span class="line">		a = <span class="built_in">find</span>(a); b = <span class="built_in">find</span>(b);</span><br><span class="line">		<span class="keyword">if</span> (a != b)</span><br><span class="line">		&#123;</span><br><span class="line">			res += w;</span><br><span class="line">			cnt++;</span><br><span class="line">			p[a] = b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt &lt; n<span class="number">-1</span>)<span class="keyword">return</span> INF;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">		Edge[j] = &#123; a,b,w &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t = <span class="built_in">Kruskal</span>();</span><br><span class="line">	<span class="keyword">if</span> (t &gt; INF / <span class="number">2</span>)<span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二十-染色法判定二分图"><a href="#二十-染色法判定二分图" class="headerlink" title="二十.染色法判定二分图"></a>二十.染色法判定二分图</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/862/">https://www.acwing.com/problem/content/862/</a></p>
<h2 id="大意：-10"><a href="#大意：-10" class="headerlink" title="大意："></a>大意：</h2><p>给定一个n个点m条边的无向图，判断其是否为二分图。</p>
<h2 id="思路：-17"><a href="#思路：-17" class="headerlink" title="思路："></a>思路：</h2><p>首先，分析易知，如果一个图为二分图，则该图一定不会存在奇数环，同时，只要一个图不存在奇数环，就一定是二分图。<br>染色法：只要一个图中不存在奇数环，从一个点开始染色为1，它的相邻点染色为2。之后每个点都把周围的点染色为与自己不同的颜色。可知，每次染色后绝不会出现矛盾的情况。<br>遍历其中所有未被染色的点，并利用深度优先搜索，对其和其周围所有点进行染色。每次遍历以该点为起点的所有边，判断边上的点是否被染色，如果未被染色，就染为与该点不同的颜色，如果该边的另一个点的颜色与自己相同，则表明该图并非二分图，返回false。</p>
<h2 id="完整代码：-3"><a href="#完整代码：-3" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;</span><br><span class="line"><span class="type">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color[x] = u;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = h[x]; j != <span class="number">-1</span>;j = ne[j])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> k = e[j];</span><br><span class="line">		<span class="keyword">if</span> (!color[k])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">dfs</span>(k, <span class="number">3</span> - u))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (color[k] == u)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!color[j])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">1</span>)) </span><br><span class="line">		&#123;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag)<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二十一-二分图的最大匹配（匈牙利算法）"><a href="#二十一-二分图的最大匹配（匈牙利算法）" class="headerlink" title="二十一.二分图的最大匹配（匈牙利算法）"></a>二十一.二分图的最大匹配（匈牙利算法）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/863/">https://www.acwing.com/problem/content/863/</a></p>
<h2 id="大意：-11"><a href="#大意：-11" class="headerlink" title="大意："></a>大意：</h2><p>给定一个已经分为两部分的二分图，两部分的点数分别为n1,n2，已知二分图中所有的边，求该二分图的最大匹配数。</p>
<h2 id="思路：-18"><a href="#思路：-18" class="headerlink" title="思路："></a>思路：</h2><h4 id="1-存储图"><a href="#1-存储图" class="headerlink" title="1.存储图"></a>1.存储图</h4><p>借助邻接表来存储图的所有边，由于匈牙利算法只考虑二分图中某一侧到另一侧的点的配对，所以只需存储一侧方向的边即可。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">	<span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-匹配"><a href="#2-匹配" class="headerlink" title="2.匹配"></a>2.匹配</h4><p>遍历一边的所有的点，对于每一个点而言，遍历所有的有向边，对于其中的一条边而言，判断边另一边的点是否已经被匹配，如果未被匹配，则将这两个点进行匹配，否则的话，则找到边那边于其匹配的点，判断其是否可以和其他点进行配对，判断方法于此相同。如果该点始终无法被转换为未匹配的状态，则继续遍历下一个边。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = h[u]; j != <span class="number">-1</span>; j = ne[j])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = e[j];</span><br><span class="line">		<span class="keyword">if</span> (!st[x])</span><br><span class="line">		&#123;</span><br><span class="line">			st[x] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (match[x] == <span class="number">0</span> || <span class="built_in">find</span>(match[x]))</span><br><span class="line">			&#123;</span><br><span class="line">				match[x] = u;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="完整代码：-4"><a href="#完整代码：-4" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n1, n2, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = h[u]; j != <span class="number">-1</span>; j = ne[j])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = e[j];</span><br><span class="line">		<span class="keyword">if</span> (!st[x])</span><br><span class="line">		&#123;</span><br><span class="line">			st[x] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (match[x] == <span class="number">0</span> || <span class="built_in">find</span>(match[x]))</span><br><span class="line">			&#123;</span><br><span class="line">				match[x] = u;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n1 &gt;&gt; n2&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="built_in">add</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n1; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">find</span>(j))res++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二十二-01背包问题"><a href="#二十二-01背包问题" class="headerlink" title="二十二.01背包问题"></a>二十二.01背包问题</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2/">https://www.acwing.com/problem/content/2/</a></p>
<h2 id="大意：-12"><a href="#大意：-12" class="headerlink" title="大意："></a>大意：</h2><p>给定n个物品，已知每件物品的体积和价值，每件物品都只有一件。要求从中挑选物品，使得满足总体积不大于V的前提下，价值最大能选到多大。</p>
<h2 id="思路：-19"><a href="#思路：-19" class="headerlink" title="思路："></a>思路：</h2><h3 id="1-状态划分："><a href="#1-状态划分：" class="headerlink" title="1.状态划分："></a>1.状态划分：</h3><h4 id="（1-集合："><a href="#（1-集合：" class="headerlink" title="（1.集合："></a>（1.集合：</h4><p>用数组f[i][j]来表示一个集合。i表示只在前i个物品中选择，j表示总体积不超过j的所有选法集合。</p>
<h4 id="（2-属性"><a href="#（2-属性" class="headerlink" title="（2.属性"></a>（2.属性</h4><p>f[i][j]中的值当为集合中所有选法中，总价值的最大值。</p>
<h3 id="2-状态计算："><a href="#2-状态计算：" class="headerlink" title="2.状态计算："></a>2.状态计算：</h3><p>对于一个集合的状态f[i][j]而言，可以划分为两种状态，第i个物品被选择和第二个物品不被选择。对于第一个情况，相当于从前i-1中个物品中选，总体积不超过j，所以易知f[i][j]&#x3D;f[i-1][j]。对于第二种情况，总价值相当于第二个物品的价值，加上该选法的价值：从前i-1个物品中选，总体积不大于j-v[i]的选法。即f[i][j]&#x3D;f[i-1][j-v[i]]+w[i]。每次对两种状态取最大值即可。</p>
<h2 id="完整代码一"><a href="#完整代码一" class="headerlink" title="完整代码一:"></a>完整代码一:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h2><p>对于该二维状态，可以优化为一维来优化。观察状态转移方程dp[i][j] &#x3D; max(dp[i][j], dp[i - 1][j - v[i]] + w[i]。对于每一个i都有第i或者i-1转移而来，所以我们可以删去i这一维，用j这一维记录最新的一层即可。所以第一个状态转移方程就变为f[j]&#x3D;f[j]为恒等式，可以删去。<br>对于第二个状态转移方程，如果直接将第一维删去的话，由于第二维是从小到大遍历，所以遍历到某一层时，其使用的dp[j-v[i]]已经被更新到了第i层而非第i-1层，所以从大到小遍历即可。</p>
<h2 id="完整代码二："><a href="#完整代码二：" class="headerlink" title="完整代码二："></a>完整代码二：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> w[N], v[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		cin &gt;&gt; v[j] &gt;&gt; w[j];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= v[j]; i--)</span><br><span class="line">			f[i] = <span class="built_in">max</span>(f[i], f[i - v[j]] + w[j]);</span><br><span class="line">	cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二十三-完全背包问题"><a href="#二十三-完全背包问题" class="headerlink" title="二十三.完全背包问题"></a>二十三.完全背包问题</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3/">https://www.acwing.com/problem/content/3/</a></p>
<h2 id="大意：-13"><a href="#大意：-13" class="headerlink" title="大意："></a>大意：</h2><p>有n种物品和容量为V的背包，每种物品可以选择的数量都为无限个。已知每种物品的体积和价值，找出不超过背包容量的前提下，可以得到的最大价值。</p>
<h2 id="思路：-20"><a href="#思路：-20" class="headerlink" title="思路："></a>思路：</h2><h3 id="状态表示："><a href="#状态表示：" class="headerlink" title="状态表示："></a>状态表示：</h3><h4 id="1-集合"><a href="#1-集合" class="headerlink" title="1.集合"></a>1.集合</h4><p>使用f[i][j]表示从前i个物品中选择，总体积不超过j的所有选法集合。</p>
<h4 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h4><p>由题意易知，f[i][j]当存储该集合中的最大值。</p>
<h3 id="状态计算："><a href="#状态计算：" class="headerlink" title="状态计算："></a>状态计算：</h3><p>对于一个集合f[i][j]来说，可以按照第i个物品被选的数量来分类。当得i个物品被选了k个时可得f[i][j]&#x3D;f[i-1][j-k<em>v[j]]+k</em>w[j]。比较所有的情况，选出最大值即可。</p>
<h2 id="优化：-1"><a href="#优化：-1" class="headerlink" title="优化："></a>优化：</h2><p>对于上述分类方法直接循环dp的话，时间复杂度过高。我们可以得出每一个集合的完整的状态转移方程，如下：f[i][j]&#x3D;max( f[i-1][j] , f[i-1][j-v[i]] + w[i],f[i-1][j-2<em>v[j]]+<em>2w[j]…)。同样，我们也可以写出f[i][j-v[i]]的完整状态转移方程f[i][j-v[i]]&#x3D;max( f[i-1][j-v[j]] , f[i-1][j-2</em>v[i]] + w[i],f[i-1][j-3</em>v[j]]+*2w[j]…)。观察后不难发现新的状态转移方程：f[i][j]&#x3D;max( f[i-1][j] , f[i][j-v[i]]+w[i] )。</p>
<h2 id="完整代码：-5"><a href="#完整代码：-5" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> w[N], v[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[j], &amp;w[j]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[j][i] = f[j<span class="number">-1</span>][i];</span><br><span class="line">			<span class="keyword">if</span> (v[j] &lt;= i)f[j][i] = <span class="built_in">max</span>(f[j][i], f[j][i - v[j]] + w[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二十四-多重背包问题"><a href="#二十四-多重背包问题" class="headerlink" title="二十四.多重背包问题"></a>二十四.多重背包问题</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/4/">https://www.acwing.com/problem/content/4/</a></p>
<h2 id="大意：-14"><a href="#大意：-14" class="headerlink" title="大意："></a>大意：</h2><p>给定n种问题和一个容量为m的背包，已知每件物品的体积，价值和数量。找出在不超出背包最大容量的前提下，最多可以拿到多大价值的总物品。</p>
<h2 id="思路：-21"><a href="#思路：-21" class="headerlink" title="思路："></a>思路：</h2><h3 id="状态表示：-1"><a href="#状态表示：-1" class="headerlink" title="状态表示："></a>状态表示：</h3><h4 id="1-集合-1"><a href="#1-集合-1" class="headerlink" title="1.集合"></a>1.集合</h4><p>f[i][j]表示在前i个物品当中选择，总体积不超过j的所有选法的集合。</p>
<h4 id="2-属性-1"><a href="#2-属性-1" class="headerlink" title="2.属性"></a>2.属性</h4><p>当前所有集合中的价值的最大值</p>
<h3 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h3><p>对于每一个状态都可以通过第i个物品被选择的数目进行分类，再取得集合中的最大值即可。</p>
<h2 id="完整代码：-6"><a href="#完整代码：-6" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N], s[N], w[N], v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v[j], &amp;w[j], &amp;s[j]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[j] &amp;&amp; k * v[j] &lt;= i; k++)</span><br><span class="line">				f[j][i] = <span class="built_in">max</span>(f[j][i], f[j - <span class="number">1</span>][i - k * v[j]] + k * w[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化：-2"><a href="#优化：-2" class="headerlink" title="优化："></a>优化：</h2><h3 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h3><p>对于一个区间0~k，区间中的所有数必然可以用1，2，4，8…2^x （2^x&lt;&#x3D;k）,k-2^x中的一部分数凑出来，并且不会凑出这之外的数字，又因为每件物品最多可以选择s个，所以可以打包成多个二进制数，转化为01背包问题。判断每一个二进制数是否选择，就可间接枚举出第i个所有选择数量的情况。</p>
<h2 id="完整代码：-7"><a href="#完整代码：-7" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N], v[N], w[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, s; cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">		<span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (k &lt;= s)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			v[cnt] = a*k, w[cnt] = b*k;</span><br><span class="line">			</span><br><span class="line">			s -= k;k *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			v[cnt] = a * s, w[cnt] = b * s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= v[j]; i--)</span><br><span class="line">			f[i] = <span class="built_in">max</span>(f[i], f[i - v[j]] + w[j]);</span><br><span class="line">			</span><br><span class="line">	cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二十五-最长上升子序列（线性dp）"><a href="#二十五-最长上升子序列（线性dp）" class="headerlink" title="二十五.最长上升子序列（线性dp）"></a>二十五.最长上升子序列（线性dp）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/897/">https://www.acwing.com/problem/content/897/</a></p>
<h2 id="大意：-15"><a href="#大意：-15" class="headerlink" title="大意："></a>大意：</h2><p>给定一个数组，找出其中最长的一个严格单调上升子序列，输出其长度。</p>
<h2 id="思路：-22"><a href="#思路：-22" class="headerlink" title="思路："></a>思路：</h2><h3 id="状态表示：-2"><a href="#状态表示：-2" class="headerlink" title="状态表示："></a>状态表示：</h3><h4 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h4><p>用数组f[i]表示以数组中第i个数结尾的子序列的长度的集合。</p>
<h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><p>由于要找最大的上升子序列，所以f[i]中应存储所有集合长度的最大值。</p>
<h3 id="状态计算：-1"><a href="#状态计算：-1" class="headerlink" title="状态计算："></a>状态计算：</h3><p>对于每一个状态f[i]，其最小值必定为1，即子序列中只包含该元素一个元素。分析易知，只要存在p[j]&lt;p[i]&amp;&amp;j&lt;i,那么f[i]必然可以从f[j]转移而来。所以可知状态转移方程为f[i]&#x3D;max(1,f[j]+1)。<br>最终遍历所有的结尾，输出最大的子序列长度即可。</p>
<h2 id="完整代码：-8"><a href="#完整代码：-8" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[j] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; j; i++)</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt; a[j])f[j] = <span class="built_in">max</span>(f[i] + <span class="number">1</span>, f[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)res = <span class="built_in">max</span>(res, f[j]);</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二十六-最短编辑距离-（同线性dp）"><a href="#二十六-最短编辑距离-（同线性dp）" class="headerlink" title="二十六.最短编辑距离 （同线性dp）"></a>二十六.最短编辑距离 （同线性dp）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/904/">https://www.acwing.com/problem/content/904/</a></p>
<h2 id="大意：-16"><a href="#大意：-16" class="headerlink" title="大意："></a>大意：</h2><p>给定两个字符串a,b，每次我们可以对于字符串a进行修改，共三种方式：1·在某位置增加一个元素 2.删除某一位置的元素 3.修改某一位置元素的值。找出最小的操作数，使得a和b完全相同。</p>
<h2 id="思路：-23"><a href="#思路：-23" class="headerlink" title="思路："></a>思路：</h2><h3 id="状态标识"><a href="#状态标识" class="headerlink" title="状态标识"></a>状态标识</h3><h4 id="集合：-1"><a href="#集合：-1" class="headerlink" title="集合："></a>集合：</h4><p>用f[j][i]表示将a字符串的前j个字母和b字符串的前i个字母完全匹配所有操作方法·的集合。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h4><p>由于我们要求的答案为最小的操作数，所以f[j][i]中应当存储的为满足条件的最小操作次数。</p>
<h3 id="状态计算-1"><a href="#状态计算-1" class="headerlink" title="状态计算"></a>状态计算</h3><p>对于f[j][i]而言，由于只能修改a，所以只要从三种修改方式分析即可。</p>
<h5 id="1-删除第j个元素"><a href="#1-删除第j个元素" class="headerlink" title="1.删除第j个元素"></a>1.删除第j个元素</h5><p>如果删除第j个元素后，a的前j-1和b的前i相同，分析易知状态转移方程f[j][i] &#x3D; f[j-1][i] + 1.</p>
<h5 id="2-在第j个元素后方增加一个元素"><a href="#2-在第j个元素后方增加一个元素" class="headerlink" title="2.在第j个元素后方增加一个元素"></a>2.在第j个元素后方增加一个元素</h5><p>如果在第j个元素后方增加一个元素，才能使得与b的前i部分相同，即代表a的前j和b的前i-1应该相同，由此可确定出状态转移方程： f[j][i] &#x3D; f[j][i-1] + 1;</p>
<h5 id="3-对第j个元素进行修改"><a href="#3-对第j个元素进行修改" class="headerlink" title="3.对第j个元素进行修改"></a>3.对第j个元素进行修改</h5><p>如果将第j个元素修改后，两字符串的前部分就能成功匹配，则该状态该由a的前j-1字符和b的前i-1完全匹配的状态转移过来。注意！如果a[j]&#x3D;&#x3D;b[i]，则该部分不需要修改。所以，最后该情况下的状态转移方程为：f[j][i] &#x3D; f[j-1][i-1] + (a[j] !&#x3D; b[i])。</p>
<h2 id="完整代码：-9"><a href="#完整代码：-9" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n1, n2;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>, &amp;n1, a+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>, &amp;n2, b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n2; j++)f[<span class="number">0</span>][j] = j;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n1; j++)f[j][<span class="number">0</span>] = j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n1; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n2; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[j][i] = <span class="built_in">min</span>(f[j - <span class="number">1</span>][i] + <span class="number">1</span>, f[j][i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (a[j] == b[i])f[j][i] = <span class="built_in">min</span>(f[j][i], f[j - <span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">else</span> f[j][i] = <span class="built_in">min</span>(f[j][i], f[j - <span class="number">1</span>][i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; f[n1][n2] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二十七</p>
<h1 id="二十七-石子合并（区间dp）"><a href="#二十七-石子合并（区间dp）" class="headerlink" title="二十七.石子合并（区间dp）"></a>二十七.石子合并（区间dp）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/284/">https://www.acwing.com/problem/content/284/</a></p>
<h2 id="大意：-17"><a href="#大意：-17" class="headerlink" title="大意："></a>大意：</h2><p>给定n堆石子，同时给出每堆石子的重量。每次可以将相邻的两堆石子合并，消耗的体力是两堆石子的质量之和。问：将所有的石子合并所需的最小体力是多少。</p>
<h2 id="思路：-24"><a href="#思路：-24" class="headerlink" title="思路："></a>思路：</h2><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><h5 id="集合：-2"><a href="#集合：-2" class="headerlink" title="集合："></a>集合：</h5><p>f[i][j]表示将第i堆石子到第j堆石子所有的石子合并所需的体力的集合。</p>
<h5 id="属性：-1"><a href="#属性：-1" class="headerlink" title="属性："></a>属性：</h5><p>由于要求所需体力的最小值，所以f[i][j]中当存储集合的最小值。</p>
<h4 id="状态计算-2"><a href="#状态计算-2" class="headerlink" title="状态计算"></a>状态计算</h4><p>由于每一堆石子都必定由其他两堆石子合并而来。所以f[i][j] &#x3D; f[i][k] + f[k][j] + sum(i,j). 所以可以通过每一堆石子由那俩堆合并来分组，枚举i到j之间的一个分界线即可。</p>
<h2 id="完整代码：-10"><a href="#完整代码：-10" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> s[N], f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)s[j] += s[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j + len - <span class="number">1</span> &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> l = j, r = j + len - <span class="number">1</span>;</span><br><span class="line">			f[l][r] = <span class="number">1e9</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt; r; k++)</span><br><span class="line">				f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二十八-最短Hamilton路径（状态压缩dp）"><a href="#二十八-最短Hamilton路径（状态压缩dp）" class="headerlink" title="二十八.最短Hamilton路径（状态压缩dp）"></a>二十八.最短Hamilton路径（状态压缩dp）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/93/">https://www.acwing.com/problem/content/93/</a></p>
<h2 id="大意：-18"><a href="#大意：-18" class="headerlink" title="大意："></a>大意：</h2><p>给定一个带有n个点的带权无向图，求从0到n-1的最短hamilton路径，hamilton路径为进过路上所有的点。</p>
<h2 id="思路：-25"><a href="#思路：-25" class="headerlink" title="思路："></a>思路：</h2><h3 id="1-状态表示"><a href="#1-状态表示" class="headerlink" title="1.状态表示"></a>1.状态表示</h3><h4 id="集合：-3"><a href="#集合：-3" class="headerlink" title="集合："></a>集合：</h4><p>用f[j][i]表示从0到i，其中经过的点的情况为j的所有走法的集合。j为一个二进制数，每一个二进制为代表该位的点是否被走过。</p>
<h4 id="属性：-2"><a href="#属性：-2" class="headerlink" title="属性："></a>属性：</h4><p>由于要找到最短路径，所以我们应存储集合中所有路径长度的最小值。</p>
<h3 id="2-状态计算"><a href="#2-状态计算" class="headerlink" title="2.状态计算"></a>2.状态计算</h3><p>对于一个状态f[j][i]，必然由j中所经过的任意一个点转移过来，所以，我们可以枚举所有的点，判断该点是否在j所压缩的状态中被走过，如果被走过，则当前状态就可能从该点转移而来。<br>由于我们要计算最小值，先将所有的状态初始化为无穷大，将f[1][0]初始化为0.</p>
<h2 id="完整代码：-11"><a href="#完整代码：-11" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i][j]);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">					<span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">						f[i][j] = <span class="built_in">min</span>(f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j], f[i][j]);</span><br><span class="line">						</span><br><span class="line">	cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二十九-动态求连续区间和（树状数组）"><a href="#二十九-动态求连续区间和（树状数组）" class="headerlink" title="二十九. 动态求连续区间和（树状数组）"></a>二十九. 动态求连续区间和（树状数组）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1266/">https://www.acwing.com/problem/content/1266/</a></p>
<h2 id="大意：-19"><a href="#大意：-19" class="headerlink" title="大意："></a>大意：</h2><p>给定一个长度为n的数组，维护以下的两种操作，修改一个元素的值，和求一个区间的和</p>
<h2 id="思路：-26"><a href="#思路：-26" class="headerlink" title="思路："></a>思路：</h2><p>本题可以利用树状数组来解决，原理较为复杂，仅介绍对应模版，树状数组几大操作:</p>
<h3 id="1-lowbit操作"><a href="#1-lowbit操作" class="headerlink" title="1.lowbit操作"></a>1.lowbit操作</h3><p>求某个二进制数的最后一位1和其后所有的0表示的十进制数。实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-add操作"><a href="#2-add操作" class="headerlink" title="2.add操作"></a>2.add操作</h3><p>对树状数组中的某个值进行修改，对第a个数加上b，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = a; j &lt;= n; j += <span class="built_in">lowbit</span>(j)) tri[j] += b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-query操作"><a href="#3-query操作" class="headerlink" title="3.query操作"></a>3.query操作</h3><p>查询某个坐标的前缀和，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = x; j; j -= <span class="built_in">lowbit</span>(j)) res += tri[j];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码：-12"><a href="#完整代码：-12" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> tri[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = a; j &lt;= n; j += <span class="built_in">lowbit</span>(j)) tri[j] += b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = x; j; j -= <span class="built_in">lowbit</span>(j)) res += tri[j];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="built_in">add</span>(j, p[j]);</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, k; cin &gt;&gt; k &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query</span>(b) - <span class="built_in">query</span>(a - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">add</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三十-筛质数-线性筛法"><a href="#三十-筛质数-线性筛法" class="headerlink" title="三十.筛质数(线性筛法)"></a>三十.筛质数(线性筛法)</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/870/">https://www.acwing.com/problem/content/870/</a></p>
<h2 id="大意：-20"><a href="#大意：-20" class="headerlink" title="大意："></a>大意：</h2><p>给定一个正整数n，求从1~n中有多少个质数。</p>
<h2 id="思路：-27"><a href="#思路：-27" class="headerlink" title="思路："></a>思路：</h2><p>本题可使用欧拉筛算法，代码模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _prime(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!st[j]) prime[cnt++] = j;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prime[i] &lt;= n / j; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			st[j * prime[i]] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (j % prime[i] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cnt中记录了有多少个质数，prime中存储着所有的质数，st记录着某个数是否已经被筛去。</p>
<h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p>*<em>对于每一个被筛掉的prime[i]<em>j，prime[i]都是其最小质因子。即每个数都只会被它的最小质因子筛掉，所以该算法时间复杂度为线性。证明如下：</em></em><br>1.如果j%prime[i]&#x3D;&#x3D;0,又因为prime从小到大枚举，则prime[i]必然是j的最小的质因子，也就必然是			j*prime[i]的最小质因子。<br>2.如果j%prime[i]!&#x3D;0,则j必不会有小于prime[i]的质因子（因为一旦存在，循环就已经break）,所以此时，		该乘积的最小质因子也为prime[i]</p>
<p><strong>对于所有的合数，一定会被筛掉，证明如下：</strong><br>如果一个数为合数，则其必然存在一个最小的质因子，也就必然会被这个质因子筛掉。</p>
<h2 id="完整代码：-13"><a href="#完整代码：-13" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _prime(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!st[j]) prime[cnt++] = j;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prime[i] &lt;= n / j; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			st[j * prime[i]] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (j % prime[i] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	_prime(n);</span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三十一-约数个数"><a href="#三十一-约数个数" class="headerlink" title="三十一.约数个数"></a>三十一.约数个数</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/872/">https://www.acwing.com/problem/content/872/</a></p>
<h2 id="大意：-21"><a href="#大意：-21" class="headerlink" title="大意："></a>大意：</h2><p>给定一个正整数x，输出x的所有的约数的个数。</p>
<h2 id="思路：-28"><a href="#思路：-28" class="headerlink" title="思路："></a>思路：</h2><p>由于证明看不懂，直接给出结论，如下：<br>如果一个数x可以被因式分解为  p1^m1 * p2^m2 * p3^m3…… * pk^mk 。则约数的个数为（1+p1）_(1 + p2) * ….._(1 + pk)。</p>
<h2 id="完整代码：-14"><a href="#完整代码：-14" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes;</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=x/j;j++)</span><br><span class="line">			<span class="keyword">while</span> (x % j == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				x /= j;</span><br><span class="line">				primes[j]++;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; <span class="number">1</span>)primes[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">	LL res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> prime : primes)res = (res*(LL)(prime.second+<span class="number">1</span>))%Mod;</span><br><span class="line">	cout &lt;&lt; res % Mod &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三十二-约数之和"><a href="#三十二-约数之和" class="headerlink" title="三十二.约数之和"></a>三十二.约数之和</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/49985/">https://www.acwing.com/activity/content/code/content/49985/</a></p>
<h2 id="大意：-22"><a href="#大意：-22" class="headerlink" title="大意："></a>大意：</h2><p>给定n个正整数，求这些正整数乘积的所有约数的和。</p>
<h2 id="思路：-29"><a href="#思路：-29" class="headerlink" title="思路："></a>思路：</h2><p>先给出结论：当把数质因数分解为p1^k1 * p2^k2 <em>… pn^kn,可得sum&#x3D; (1 + p1 + p1^2 + … + p1^k)</em> (1+p2 + p2^2 +…)<em>…</em>(1 + pn + pn^2 + …).。<br>证明：将结果sum通过乘法分配律展开即可。<br>求解（1 + pk + pk^2. .. pk^x ）:<br>先记录总阶数x的值，观察易发现，上式等于(1 + pk + pk^2… pk^(x-1) )*pk + 1.所以本题可用递推的方法求解。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> prime : primes)</span><br><span class="line">&#123;</span><br><span class="line">	LL t = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> p = prime.first, a = prime.second;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(a--)t = (t * p + <span class="number">1</span>) % Mod;</span><br><span class="line">	res = res*t %Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码：-15"><a href="#完整代码：-15" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;primes;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=x/j;j++)</span><br><span class="line">			<span class="keyword">while</span> (x % j == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				x /= j;</span><br><span class="line">				primes[j]++;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; <span class="number">1</span>)primes[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">	LL res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> prime : primes)</span><br><span class="line">	&#123;</span><br><span class="line">		LL t = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> p = prime.first, a = prime.second;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(a--)t = (t * p + <span class="number">1</span>) % Mod;</span><br><span class="line">		res = res*t %Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三十三-最大公约数（欧几里得定理）"><a href="#三十三-最大公约数（欧几里得定理）" class="headerlink" title="三十三. 最大公约数（欧几里得定理）"></a>三十三. 最大公约数（欧几里得定理）</h1><p>题目传送门:<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/874/">https://www.acwing.com/problem/content/874/</a></p>
<h2 id="大意：-23"><a href="#大意：-23" class="headerlink" title="大意："></a>大意：</h2><p>给定n对正整数a,b， 找出a和b的最大的公约数</p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>对于a和b两个数的最大公约数，它的值等于a和a%b的最大公约数相等.所以最终代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="证明：-1"><a href="#证明：-1" class="headerlink" title="证明："></a>证明：</h2><p>对于a和b的公约数d，即d|a,d|b。易知d|(ax+by)。又因为a mod b &#x3D; a - [a&#x2F;b]<em>b， 所以令c等于[a&#x2F;b]，即 a mod b &#x3D; a - c</em>b 。考虑b和a - c*b 的所有公约数，如果存在x， 使得x|（a-c_b），那么必然会有x | (a-cb + c_b), 所以必有x|a， 并且x|b。 可知对于所有的d，必然被包含于x中 。对于所有的x，也全部被包含于d中，所以x和d完全等价</p>
<h2 id="完整代码：-16"><a href="#完整代码：-16" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">gcd</span>(a, b) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三十四</p>
<h1 id="三十四-欧拉函数"><a href="#三十四-欧拉函数" class="headerlink" title="三十四.欧拉函数"></a>三十四.欧拉函数</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/875/">https://www.acwing.com/problem/content/875/</a></p>
<h2 id="大意：-24"><a href="#大意：-24" class="headerlink" title="大意："></a>大意：</h2><p>欧拉函数定义：1~n中与n互质的数的个数。给定n个数a，输出每个a的欧拉函数值。</p>
<h2 id="结论：-1"><a href="#结论：-1" class="headerlink" title="结论："></a>结论：</h2><p>对于一个整数X，有算数基本定理，对任意X，可写为X &#x3D; p1^k1 * p2^k2 <em>…. pn^kn。则X的欧拉函数值为：X</em>(1-1&#x2F;p1)<em>(1-1&#x2F;p2)</em>…(1-1&#x2F;pn)。</p>
<h2 id="证明：-2"><a href="#证明：-2" class="headerlink" title="证明："></a>证明：</h2><p>由于质数的性质，从1~X中所有为p1,p2..pn的倍数的数都不可能为质数。所以我们可以讲所有的pk的倍数删去。但是，如果某个数同时是pi, pj的倍数，则会被重复删去，我们应该重新加上1&#x2F;(pj <em>pi)，但同样，可能会同时存在某个数，被重复加入，所以还需减去1&#x2F;(pu</em>pv<em>pm)。由此往下递推，最终的结果为X-(1&#x2F;p1,1&#x2F;p2….)+(1&#x2F;(p1</em>p2)+1&#x2F;(p2<em>p3)….)-…….，化简可得X</em>(1-1&#x2F;p1)*(1-1&#x2F;p2)….</p>
<h2 id="完整代码：-17"><a href="#完整代码：-17" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a; cin &gt;&gt; a;</span><br><span class="line">		<span class="type">int</span> res = a;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= a / j; j++)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">if</span>(a%j==<span class="number">0</span>)&#123;</span><br><span class="line">			    res = res / j*(j<span class="number">-1</span>);</span><br><span class="line">			    <span class="keyword">while</span> (a % j == <span class="number">0</span>)a /= j;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a &gt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三十五-快速幂"><a href="#三十五-快速幂" class="headerlink" title="三十五.快速幂"></a>三十五.快速幂</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/91/">https://www.acwing.com/problem/content/91/</a></p>
<h2 id="题目大意：-9"><a href="#题目大意：-9" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定三个数a,b,p，求a^b mod p的值，并输出该结果</p>
<h2 id="思路：-30"><a href="#思路：-30" class="headerlink" title="思路："></a>思路：</h2><p>分析如图：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/34314328/1668767102577-63d5f8fa-27b0-4a93-9c0c-2aa0c7ac1c2a.jpeg"><br>易知，对于一个数的任何次幂，都可以用其二进制来拆分来减少运算次数。</p>
<h3 id="1-判断b的最后一位"><a href="#1-判断b的最后一位" class="headerlink" title="1.判断b的最后一位"></a>1.判断b的最后一位</h3><p>观察易知，当b的二进制位为1时，结果就当乘上a^2^n，其中n表示该1在b的二进制的位数，所以可每次判断b的二进制最后一位是否为1，再将b向右移动一位。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (b &amp; <span class="number">1</span>)num = num * (a % p);</span><br><span class="line">	a *= a%p;</span><br><span class="line">	b=b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-将a的不同次幂相乘"><a href="#2-将a的不同次幂相乘" class="headerlink" title="2.将a的不同次幂相乘"></a>2.将a的不同次幂相乘</h3><p>每次b右移之后将a进行平方，使得a的值与最开始的a的2^n次幂始终相等，记录结果即可。<br>注意：由于数据太大，需要多次进行取模操作，防止溢出</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b, p;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">1</span>%p;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)num = num * (a % p);</span><br><span class="line">		a *= a%p;</span><br><span class="line">		b=b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三十六-字符串哈希"><a href="#三十六-字符串哈希" class="headerlink" title="三十六.字符串哈希"></a>三十六.字符串哈希</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/843/">https://www.acwing.com/problem/content/843/</a></p>
<h2 id="大意：-25"><a href="#大意：-25" class="headerlink" title="大意："></a>大意：</h2><p>给定一个长度为n的字符串，每次询问两个区间，判断两个区间内的字符串是否相</p>
<h2 id="思路：-31"><a href="#思路：-31" class="headerlink" title="思路："></a>思路：</h2><h5 id="将准备哈希的字符串当成一个p进制数"><a href="#将准备哈希的字符串当成一个p进制数" class="headerlink" title="将准备哈希的字符串当成一个p进制数"></a>将准备哈希的字符串当成一个p进制数</h5><p>为了将字符串进行取模运算，可以把字符串看做一个p进制数，在取模哈希。一般情况下，p取值131，取模用值Mod一般取2^64以减少哈希冲突的概率。注：字符串哈希一般认为不会出现哈希冲突。</p>
<h5 id="处理每一段的子字符串的哈希值"><a href="#处理每一段的子字符串的哈希值" class="headerlink" title="处理每一段的子字符串的哈希值"></a>处理每一段的子字符串的哈希值</h5><p>可以提前处理出字符串的所有前缀哈希值。处理代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line">	h[j] = h[j - <span class="number">1</span>] * P + str[j];</span><br><span class="line">	p[j] = p[j - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>对于每一个区间字符串[l, r]。可以看成两个P进制的数相减后所得的结果。由数字特性易知，哈希值X = h[r] - h[l] * p^(r - l + 1).这是由于需要将两个字符串同步到相同的位数，再相减。
</code></pre>
<h5 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h5><p>由于我们一般对2^64来取模，可以直接使用unsigned long long来存储数据，每当数字发生溢出时，即可自动取模。</p>
<h2 id="完整代码：-18"><a href="#完整代码：-18" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N], p[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">	p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		h[j] = h[j - <span class="number">1</span>] * P + str[j];</span><br><span class="line">		p[j] = p[j - <span class="number">1</span>] * P;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">find</span>(l1, r1) == <span class="built_in">find</span>(l2, r2))<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三十七-国王游戏（高精度）"><a href="#三十七-国王游戏（高精度）" class="headerlink" title="三十七.国王游戏（高精度）"></a>三十七.国王游戏（高精度）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/116/">https://www.acwing.com/problem/content/116/</a></p>
<h2 id="大意：-26"><a href="#大意：-26" class="headerlink" title="大意："></a>大意：</h2><p>国王站在第一排，大臣按某一顺序往后排，每个大臣获得的金币数为前面所有大臣左手心数字的乘积除以自己的右手♥的向下取整的值。按照某种排序使获得最大奖赏的大臣所得到的金币经可能的少，求出该金币数。</p>
<h2 id="思路：-32"><a href="#思路：-32" class="headerlink" title="思路："></a>思路：</h2><h4 id="贪心思路："><a href="#贪心思路：" class="headerlink" title="贪心思路："></a>贪心思路：</h4><p>一种合理贪心思路为将所有的大臣按照双手数字之积的大小从小到大进行排序。思路的证明较为复杂，此处不再讨论。</p>
<h4 id="高精度："><a href="#高精度：" class="headerlink" title="高精度："></a>高精度：</h4><p>由于所求的值可能过大，本题需要使用到高精度算法。此处主要记录高精度的应用。</p>
<h6 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h6><p>一般使用一个vector数组来存储一个高精度数。并且为了便于处理进位问题，一般将数字位按照逆序存储，及高位在后，低位在前。</p>
<h5 id="高精度加法："><a href="#高精度加法：" class="headerlink" title="高精度加法："></a>高精度加法：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt;a, vector&lt;<span class="type">int</span>&gt;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a.<span class="built_in">size</span>() || j &lt; b.<span class="built_in">size</span>()||k&gt;<span class="number">0</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j &lt; a.<span class="built_in">size</span>()) k += a[j];</span><br><span class="line">		<span class="keyword">if</span> (j &lt; b.<span class="built_in">size</span>()) k += b[j];</span><br><span class="line">		d.<span class="built_in">push_back</span>(k % <span class="number">10</span>);</span><br><span class="line">		k /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="高精度减法："><a href="#高精度减法：" class="headerlink" title="高精度减法："></a>高精度减法：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Del</span><span class="params">(vector&lt;<span class="type">int</span>&gt;a, vector&lt;<span class="type">int</span>&gt;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;p;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>() || k != <span class="number">0</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		k += a[j];</span><br><span class="line">		<span class="keyword">if</span> (j &lt; b.<span class="built_in">size</span>())k -= b[j];</span><br><span class="line">		k += <span class="number">10</span>;</span><br><span class="line">		p.<span class="built_in">push_back</span>(k % <span class="number">10</span>);</span><br><span class="line">		k/=<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>)k = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> k = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; a.<span class="built_in">size</span>())p.<span class="built_in">push_back</span>(a[j++]);</span><br><span class="line">	<span class="keyword">while</span> (p.<span class="built_in">size</span>()&gt; <span class="number">1</span> &amp;&amp; p.<span class="built_in">back</span>() == <span class="number">0</span>)p.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="高精度乘法："><a href="#高精度乘法：" class="headerlink" title="高精度乘法："></a>高精度乘法：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a.<span class="built_in">size</span>()||k&gt;<span class="number">0</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j&lt;a.<span class="built_in">size</span>())k += b * a[j];</span><br><span class="line">		d.<span class="built_in">push_back</span>(k % <span class="number">10</span>);</span><br><span class="line">		k /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (d.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; d.<span class="built_in">back</span>() == <span class="number">0</span>)d.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="高精度除法："><a href="#高精度除法：" class="headerlink" title="高精度除法："></a>高精度除法：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Del</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span>&amp; b, <span class="type">int</span>&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = a.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">	&#123;</span><br><span class="line">		r = r * <span class="number">10</span> + a[j];</span><br><span class="line">		d.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">		r %= b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">while</span> (d.<span class="built_in">size</span>() != <span class="number">1</span> &amp;&amp; d.<span class="built_in">back</span>() == <span class="number">0</span>)d.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码：-19"><a href="#完整代码：-19" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">using</span> PII = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line">PII p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(PII a,PII b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first*a.second &lt; b.first*b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">del</span><span class="params">(vector&lt;<span class="type">int</span>&gt;a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = a.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">	&#123;</span><br><span class="line">		t = t * <span class="number">10</span> + a[j];</span><br><span class="line">		<span class="type">int</span> x = t / b;</span><br><span class="line">		<span class="keyword">if</span> (x || flag)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			c.<span class="built_in">push_back</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		t %= b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c.<span class="built_in">rbegin</span>(), c.<span class="built_in">rend</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a.<span class="built_in">size</span>(); j++)</span><br><span class="line">	&#123;</span><br><span class="line">		t += a[j] * b;</span><br><span class="line">		c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">		t /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (t)</span><br><span class="line">	&#123;</span><br><span class="line">		c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">		t /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(vector&lt;<span class="type">int</span>&gt;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = p.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">		cout &lt;&lt; p[j];</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">max_vec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;a, vector&lt;<span class="type">int</span>&gt;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>()) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">if</span> (a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>()) <span class="keyword">return</span> b;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(a.<span class="built_in">rbegin</span>(), a.<span class="built_in">rend</span>()) &gt; <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">rbegin</span>(), b.<span class="built_in">rend</span>()))</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p[j].first, &amp;p[j].second);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxNum</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j) </span><br><span class="line">		&#123;</span><br><span class="line">			maxNum = <span class="built_in">max_vec</span>(maxNum, <span class="built_in">del</span>(a,p[j].second));</span><br><span class="line">		&#125;</span><br><span class="line">		a = <span class="built_in">mul</span>(a, p[j].first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">output</span>(maxNum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == tr[u].r) tr[u].sum += v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k, a, b;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, a, b));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">1</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> g[N][N],dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span> (!st[i] &amp;&amp; (t == <span class="number">-1</span> || dist[i] &lt; dist[t]))</span><br><span class="line">				t = i;</span><br><span class="line">		<span class="keyword">if</span> (j &amp;&amp; dist[t] == INF)<span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (j)res += dist[t];</span><br><span class="line">		st[t] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)dist[i] = <span class="built_in">min</span>(dist[i], g[t][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">	<span class="keyword">if</span> (t &gt; INF / <span class="number">2</span>)<span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N],h[N], idx;</span><br><span class="line"><span class="type">int</span> d[N], q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dd = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		<span class="keyword">if</span> (!d[j]) q[++tt] = j;</span><br><span class="line">	<span class="keyword">while</span> (dd &lt;= tt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = q[dd++];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = h[t]; j != <span class="number">-1</span>; j = ne[j])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x = e[j];</span><br><span class="line">			d[x]--;</span><br><span class="line">			<span class="keyword">if</span> (d[x] == <span class="number">0</span>)q[++tt] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="built_in">add</span>(a, b);</span><br><span class="line">		d[b]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">topsort</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)cout &lt;&lt; q[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三十八-筛法求欧拉函数"><a href="#三十八-筛法求欧拉函数" class="headerlink" title="三十八.筛法求欧拉函数"></a>三十八.筛法求欧拉函数</h1><h1 id="三十九-快速幂求逆元"><a href="#三十九-快速幂求逆元" class="headerlink" title="三十九.快速幂求逆元"></a>三十九.快速幂求逆元</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/878/">https://www.acwing.com/problem/content/878/</a></p>
<h2 id="大意：-27"><a href="#大意：-27" class="headerlink" title="大意："></a>大意：</h2><p>给定n组数a和p，求出a模上p的乘法逆元。给出逆元的定义：对于任意数数a，和某一数b则它们在摸p的意义下的逆元x会满足以下性质，a&#x2F;b | a*x (mod p)。且b和p必须互质，否则不存在逆元。</p>
<h2 id="结论：-2"><a href="#结论：-2" class="headerlink" title="结论："></a>结论：</h2><p>对于a模上p的逆元x，x &#x3D; a^p-2。当且仅当p和a互质时，该逆元x存在。</p>
<h2 id="证明：-3"><a href="#证明：-3" class="headerlink" title="证明："></a>证明：</h2><p>有定义可知，a  &#x2F; b | a*x (mod p)。 对等式两边同时乘上b&#x2F;a。化简后可得到 1 | b * x (mod p)。 由费马小定理可知  a * a ^ p-2 | 1 (mod p)。对比于上式可知，x &#x3D; a^ p-2.</p>
<h2 id="完整代码：-20"><a href="#完整代码：-20" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)ans = ans * a % p;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = a * a % p;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, p; cin &gt;&gt; a &gt;&gt; p;</span><br><span class="line">            <span class="type">int</span> res = <span class="built_in">qmi</span>(a, p - <span class="number">2</span>, p);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( a % p)</span><br><span class="line">                cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四十-扩展欧几里得算法"><a href="#四十-扩展欧几里得算法" class="headerlink" title="四十.扩展欧几里得算法"></a>四十.扩展欧几里得算法</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/879/">https://www.acwing.com/problem/content/879/</a></p>
<h2 id="大意：-28"><a href="#大意：-28" class="headerlink" title="大意："></a>大意：</h2><p>给定n对数a,b，对于每队a,b，求出x,y使得 x_a + y_b &#x3D; gcb(a,b)。输出每组a,b即可。</p>
<h3 id="裴蜀定理："><a href="#裴蜀定理：" class="headerlink" title="裴蜀定理："></a>裴蜀定理：</h3><p>对于任意数a，b,都必然存在非零整数x,y使得x_a + y_b &#x3D; gcb(a,b)。</p>
<h2 id="思路：-33"><a href="#思路：-33" class="headerlink" title="思路："></a>思路：</h2><p>由欧几里得算法可知，gcb(a,b) &#x3D; gcb(b,a%b)。先考虑在欧几里得的边界情况，即b &#x3D; 0,时，此时可知，x  &#x3D;1,y &#x3D; 0 必然为一组合理的解。对于一般情况而言，每次递归结束后得到的x,y必然满足 b*y + (a-[a&#x2F;b]*b)_x &#x3D;&#x3D; gcb(a,b)。化简可得 a * x + (y - [a&#x2F;b]_x) *b  &#x3D; gcb(a.b)。所以需要将y更新为 y - [a&#x2F;b] * b,即可继续递归到下一层。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码:"></a>完整代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcb</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b)</span><br><span class="line">	&#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> d = <span class="built_in">exgcb</span>(b, a % b, y, x);</span><br><span class="line">	y -= a / b * x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		<span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="built_in">exgcb</span>(a,b,x,y);</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四十一-高斯消元解线性方程组"><a href="#四十一-高斯消元解线性方程组" class="headerlink" title="四十一.高斯消元解线性方程组"></a>四十一.高斯消元解线性方程组</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/885/">https://www.acwing.com/problem/content/885/</a></p>
<h2 id="大意：-29"><a href="#大意：-29" class="headerlink" title="大意："></a>大意：</h2><p>给定由n个方程组成的，带有n个未知数的线性方程组。求解这个方程组，并输出结果。</p>
<h2 id="思路：-34"><a href="#思路：-34" class="headerlink" title="思路："></a>思路：</h2><p>对于由每个方程的每个未知量放在一块形成的矩阵，可以进行以下操作，而不会改变方程解的结果：1.将某一行的所有数乘以一个数。2.将某两行调换位置。3.可以把某一行的数加上任意其他行的整数倍。</p>
<h2 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h2><p>从前到后遍历每一列，在有效行中找到该列的绝对值最大的一行，把改行移动到有效行的第一行。再由第一个操作，如果该最大值不为0，则把该列的值修改为1。再通过第三条性质，把剩余的有效行的该列都修改为0。再把第一行视为无效行。如果最大值为0，则直接走到下一列。最后再通过第3个操作消元得出结果即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">guss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> c, r;</span><br><span class="line">	<span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = r;   <span class="comment">//最大的行</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=r;j&lt;n;j++)   <span class="comment">//找到最大的系数</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(a[j][c])&gt;<span class="built_in">abs</span>(a[t][c]))</span><br><span class="line">				t = j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(a[t][c]) &lt; eps)<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = c; j &lt;= n; j++)<span class="built_in">swap</span>(a[t][j], a[r][j]);   <span class="comment">//移动至首行</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j--)a[r][j] /= a[r][c];     <span class="comment">//首行系数消除1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = r + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">abs</span>(a[j][c]) &gt; eps)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i--)</span><br><span class="line">					a[j][i] -= a[r][i] * a[j][c];</span><br><span class="line">			&#125;</span><br><span class="line">		r++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (r &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = r; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">abs</span>(a[j][n]) &gt; eps) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = j + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">			a[j][n] -= a[j][i] * a[i][n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[j][i]);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t = <span class="built_in">guss</span>();</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">if</span>(<span class="built_in">abs</span>(a[j][n]) &lt; eps) a[j][n] = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[j][n]);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四十二-雪花雪花雪花（最小表示法）"><a href="#四十二-雪花雪花雪花（最小表示法）" class="headerlink" title="四十二.雪花雪花雪花（最小表示法）"></a>四十二.雪花雪花雪花（最小表示法）</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/139/">https://www.acwing.com/problem/content/139/</a></p>
<h2 id="大意：-30"><a href="#大意：-30" class="headerlink" title="大意："></a>大意：</h2><p>给定n朵雪花，每个雪花带有6个角，每片的雪花都可以顺时针或者逆时针旋转，得到的依旧是同一个雪花。判断这n朵雪花中是否存在相同的雪花。</p>
<h2 id="思路：-35"><a href="#思路：-35" class="headerlink" title="思路："></a>思路：</h2><p>对于给定的所有的雪花，我们可以将其正向和反向都求一边最小表示，以下给出最小表示的定义：对于一个字符串，其排列的字典序最小的变形串即为最小表示。易知，相同的雪花的正向和逆向最小表示也必然有至少一对相同。</p>
<h4 id="最小表示求法："><a href="#最小表示求法：" class="headerlink" title="最小表示求法："></a>最小表示求法：</h4><p>记录所有的变形串：只需把字符串复制一遍加在字符串的后面，再每次扫描对应长度即可得到所有的变形字串。<br>算法流程：假如对新字符串进行匹配，从i和j的位置开始，如果s[i+k]和s[j+k]相同，就k++，并再次比较。如果出现情况s[i+k]&gt;s[j+k]，那么s[i],s[i+1]…s[i+k]都不可能是最小表示，因为必有对应的s[j+x]比她更小，所以这时候我们可以直接是i等于i+k+1再继续匹配,注意如果此时i&#x3D;&#x3D;j，则需要再将i加上1。</p>
<h4 id="哈希表求解："><a href="#哈希表求解：" class="headerlink" title="哈希表求解："></a>哈希表求解：</h4><p>由于要求是否存在相同的字符串，每次只需把每朵雪花的最小表示存进来即可。注意：如果某朵雪花的正反最小表示相同，则只需存一次即可。</p>
<h2 id="完整代码：-21"><a href="#完整代码：-21" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_min</span><span class="params">(<span class="type">int</span>* snow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> s[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">12</span>; j++)s[j] = snow[j % <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>, k;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; <span class="number">6</span> &amp;&amp; j &lt; <span class="number">6</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">6</span> &amp;&amp; s[i + k] == s[j + k]; k++);</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">6</span>)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s[i + k] &gt; s[j + k])</span><br><span class="line">		&#123;</span><br><span class="line">			i += k + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i == j)i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			j += k + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (j == i)j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	k = <span class="built_in">min</span>(j, i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)snow[j] = s[j + k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putIn</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1 = <span class="string">&quot;&quot;</span>, s2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">		s1 += <span class="built_in">to_string</span>(a[j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">		s2 += <span class="built_in">to_string</span>(b[j]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    cout&lt;&lt;s1&lt;&lt;&#x27; &#x27;&lt;&lt;s2&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(s1 == s2)</span><br><span class="line">    &#123;</span><br><span class="line">        prime[s1]++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">	prime[s1]++;</span><br><span class="line">	prime[s2]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> * a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++)</span><br><span class="line">    cout&lt;&lt;a[j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> snow[<span class="number">6</span>];</span><br><span class="line">	<span class="type">int</span> lsnow[<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;snow[i]);</span><br><span class="line">			lsnow[<span class="number">5</span> - i] = snow[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">get_min</span>(snow);</span><br><span class="line">		<span class="built_in">get_min</span>(lsnow);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">putIn</span>(snow, lsnow);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	print(snow);</span></span><br><span class="line"><span class="comment">//	print(lsnow);</span></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> t : prime)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (t.second &gt; <span class="number">1</span>)flag = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag)<span class="built_in">puts</span>(<span class="string">&quot;No two snowflakes are alike.&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Twin snowflakes found.&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四十三-多重背包III"><a href="#四十三-多重背包III" class="headerlink" title="四十三.多重背包III"></a>四十三.多重背包III</h1><p>题目传送门：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/6/">https://www.acwing.com/problem/content/description/6/</a></p>
<h2 id="大意：-31"><a href="#大意：-31" class="headerlink" title="大意："></a>大意：</h2><p>类似与普通的多重背包，有一个体积为m的背包，给定n个物体，知道每个物体的体积和价值及数量。求在所选的物品不超过背包最大容积的情况下，所能获得的最大价值。</p>
<h2 id="思路：-36"><a href="#思路：-36" class="headerlink" title="思路："></a>思路：</h2><p>集合：用f[i][j]表示在前i个物品中选择，最大体积不超过j的所有选法的集合。<br>属性：表示所有集合中价值的最大值。<br>首先给出多重背包的原始的状态转移方程：f[i][j] &#x3D; max(f[i-1][j], f[i-1][j-v] + w, …. , f[i - 1][j - sv] + sw).<br>我们可以继续给出f[i][j-v], f[i][j - 2v] …. f[i][r]的状态转移方程,其中的r的含义为在当前完全背包的情况下，把第i件物品选到不能再选的时候，剩下的体积的余数。方程如下：<br>f[i][j] &#x3D; max(f[i-1][j], f[i-1][j-v] + w, …. , f[i - 1][j - sv] + sw)<br>        f[i][j - v] &#x3D; max(f[i-1][j-v],    …..      f[i-1][j-sv] + (s-1)w ,  f[i-1][j-(s+1)v] + sw).<br>………………<br>f[i][r+2v]&#x3D;max( f[i−1][r+2v] ,  f[i−1][r+v]+w ,  f[i−1][r] + 2w)<br>f[i][r+v]&#x3D;max( f[i−1][r+v], f[i−1][r] + w )<br>f[i][r]&#x3D;f[i−1][r]</p>
<p>此时，我们可以发现，f[i][i+v] &#x3D; max(f[i][r] + w , f[i-1][r].并可以继续类似于完全背包问题，从后递推上面的每步状态转移方程。并且，我们在做递推时，我们只会用到体积不超过v*s的所有状态，并取其最大值。所以该问题转化为一个n个单调队列处理滑动窗口最大值的题目。<br>同时，我们注意到，每次计算第i个物品时，只会用到第i-1层的状态，所以我们可以将其第一维给优化掉，原理类似于01背包的空间优化，不展开描述。</p>
<h2 id="完整代码：-22"><a href="#完整代码：-22" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> dp[N], pre[N], q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(pre, dp, <span class="keyword">sizeof</span> dp);</span><br><span class="line">		<span class="type">int</span> v, w, s;</span><br><span class="line">		cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v; i++)  <span class="comment">//枚举的余数</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> t = i; t &lt;= m; t+=v)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; t - s * v) hh++;</span><br><span class="line">				<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; pre[q[tt]] - (q[tt] - i) / v * w &lt;= pre[t] - (t - i) / v * w) tt--;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">					dp[t] = <span class="built_in">max</span>(dp[t], pre[q[hh]] + (t - q[hh]) / v * w);</span><br><span class="line">				q[++tt] = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四十四"><a href="#四十四" class="headerlink" title="四十四."></a>四十四.</h1>
        </div>
        <footer class="article-footer">
            



    <a data-url="http://example.com/2023/05/30/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" data-id="clinz8wfw0004lwta2nrra0fd" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "ZiYang Chen"
        },
        
        "image": "http://example.comhttps://cdn.nlark.com/yuque/0/2022/jpeg/34314328/1669130391230-422c2efc-0f98-42b6-8a2e-83d5d8eefd5d.jpeg",
        "keywords": "",
        "genre": "",
        "datePublished": "2023-05-30",
        "dateCreated": "2023-05-30",
        "dateModified": "2023-05-30",
        "url": "http://example.com/2023/05/30/基础算法模板/",
        "description": "一.快速排序题目传送门：https://www.acwing.com/problem/content/description/787/
题目大意：给定一个无序数组，将数组在一定时间内排序后，按顺序输出即可。
快速排序思路：1.在区间上先任取一点对取得的点x左右的数据进行处理，将小于该点的元素放在左边，大于该点的元素放在右边
左右数据处理方法建立两个指针j,i分别在最左边和最右边，对于指针j，如果过",
        "wordCount": 16274
    }
</script>

</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>


    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="twitter" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-twitter"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="facebook" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-facebook"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="stack-overflow" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-stack-overflow"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/ppoffice/hexo-theme-hueman" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="weibo" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-weibo"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="rss" href="/atom.xml" target="_blank" rel="noopener">
                        <i class="icon fa fa-rss"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
    
        <a href="/2023/05/30/newpapername/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">上一篇</strong>
        <p class="article-nav-title">newpapername</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2023/05/30/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" class="thumbnail">
    
    
        <span style="background-image:url(https://cdn.nlark.com/yuque/0/2022/jpeg/34314328/1669130391230-422c2efc-0f98-42b6-8a2e-83d5d8eefd5d.jpeg)" alt="" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2023/05/30/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" class="title"></a></p>
                            <p class="item-date"><time datetime="2023-05-30T13:42:48.629Z" itemprop="datePublished">2023-05-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2023/05/30/newpapername/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2023/05/30/newpapername/" class="title">newpapername</a></p>
                            <p class="item-date"><time datetime="2023-05-30T12:57:43.000Z" itemprop="datePublished">2023-05-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2023/05/30/hello-world/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2023/05/30/hello-world/" class="title">Hello World</a></p>
                            <p class="item-date"><time datetime="2023-05-30T10:38:57.014Z" itemprop="datePublished">2023-05-30</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">3</span></li></ul>
        </div>
    </div>


            
                

            
                

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2023 ZiYang Chen</p>
                
                <p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="https://github.com/ppoffice" target="_blank">PPOffice</a></p>
                
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

    </div>
    
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'http://example.com/2023/05/30/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>





    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    

    
    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


</body>
</html>
